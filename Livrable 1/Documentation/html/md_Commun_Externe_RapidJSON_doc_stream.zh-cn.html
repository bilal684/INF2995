<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simulateur de robot - INF2990 - Eq.11: 流</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simulateur de robot - INF2990 - Eq.11
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">流 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>在RapidJSON中，<code><a class="el" href="classrapidjson_1_1_stream.html" title="Concept for reading and writing characters. ">rapidjson::Stream</a></code>是用於读写JSON的概念（概念是指C++的concept）。在这里我们先介绍如何使用RapidJSON提供的各种流。然后再看看如何自行定义流。</p>
<h1><a class="anchor" id="MemoryStreams"></a>
Memory Streams</h1>
<p>内存流把JSON存储在内存之中。</p>
<h2><a class="anchor" id="StringStream"></a>
StringStream (Input)</h2>
<p><code>StringStream</code>是最基本的输入流，它表示一个完整的、只读的、存储于内存的JSON。它在<code><a class="el" href="rapidjson_8h.html" title="common definitions and configuration ">rapidjson/rapidjson.h</a></code>中定义。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="document_8h.html">rapidjson/document.h</a>&quot;</span> <span class="comment">// 会包含 &quot;rapidjson/rapidjson.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> json[] = <span class="stringliteral">&quot;[1, 2, 3, 4]&quot;</span>;</div><div class="line"><a class="code" href="struct_generic_string_stream.html">StringStream</a> s(json);</div><div class="line"></div><div class="line"><a class="code" href="class_generic_document.html">Document</a> d;</div><div class="line">d.<a class="code" href="class_generic_document.html#afe94c0abc83a20f2d7dc1ba7677e6238">ParseStream</a>(s);</div></div><!-- fragment --><p>由于这是非常常用的用法，RapidJSON提供<code>Document::Parse(const char*)</code>去做完全相同的事情：</p>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> json[] = <span class="stringliteral">&quot;[1, 2, 3, 4]&quot;</span>;</div><div class="line"><a class="code" href="class_generic_document.html">Document</a> d;</div><div class="line">d.<a class="code" href="class_generic_document.html#aebd4e7fddd80c1e1174837aee6d2159b">Parse</a>(json);</div></div><!-- fragment --><p>需要注意，<code>StringStream</code>是<code><a class="el" href="struct_generic_string_stream.html" title="Read-only string stream. ">GenericStringStream</a>&lt;<a class="el" href="struct_u_t_f8.html" title="UTF-8 encoding. ">UTF8</a>&lt;&gt; &gt;</code>的typedef，使用者可用其他编码类去代表流所使用的字符集。</p>
<h2><a class="anchor" id="StringBuffer"></a>
StringBuffer (Output)</h2>
<p><code>StringBuffer</code>是一个简单的输出流。它分配一个内存缓冲区，供写入整个JSON。可使用<code>GetString()</code>来获取该缓冲区。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rapidjson/stringbuffer.h&quot;</span></div><div class="line"></div><div class="line"><a class="code" href="class_generic_string_buffer.html">StringBuffer</a> buffer;</div><div class="line"><a class="code" href="class_writer.html">Writer&lt;StringBuffer&gt;</a> writer(buffer);</div><div class="line">d.Accept(writer);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* output = buffer.GetString();</div></div><!-- fragment --><p>当缓冲区满溢，它将自动增加容量。缺省容量是256个字符（UTF8是256字节，UTF16是512字节等）。使用者能自行提供分配器及初始容量。</p>
<div class="fragment"><div class="line"><a class="code" href="class_generic_string_buffer.html">StringBuffer</a> buffer1(0, 1024); <span class="comment">// 使用它的分配器，初始大小 = 1024</span></div><div class="line"><a class="code" href="class_generic_string_buffer.html">StringBuffer</a> buffer2(allocator, 1024);</div></div><!-- fragment --><p>如无设置分配器，<code>StringBuffer</code>会自行实例化一个内部分配器。</p>
<p>相似地，<code>StringBuffer</code>是<code><a class="el" href="class_generic_string_buffer.html" title="Represents an in-memory output stream. ">GenericStringBuffer</a>&lt;<a class="el" href="struct_u_t_f8.html" title="UTF-8 encoding. ">UTF8</a>&lt;&gt; &gt;</code>的typedef。</p>
<h1><a class="anchor" id="FileStreams"></a>
File Streams</h1>
<p>当要从文件解析一个JSON，你可以把整个JSON读入内存并使用上述的<code>StringStream</code>。</p>
<p>然而，若JSON很大，或是内存有限，你可以改用<code><a class="el" href="class_file_read_stream.html" title="File byte stream for input using fread(). ">FileReadStream</a></code>。它只会从文件读取一部分至缓冲区，然后让那部分被解析。若缓冲区的字符都被读完，它会再从文件读取下一部分。</p>
<h2><a class="anchor" id="FileReadStream"></a>
FileReadStream (Input)</h2>
<p><code><a class="el" href="class_file_read_stream.html" title="File byte stream for input using fread(). ">FileReadStream</a></code>通过<code>FILE</code>指针读取文件。使用者需要提供一个缓冲区。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rapidjson/filereadstream.h&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;big.json&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span>); <span class="comment">// 非Windows平台使用&quot;r&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> readBuffer[65536];</div><div class="line"><a class="code" href="class_file_read_stream.html">FileReadStream</a> is(fp, readBuffer, <span class="keyword">sizeof</span>(readBuffer));</div><div class="line"></div><div class="line"><a class="code" href="class_generic_document.html">Document</a> d;</div><div class="line">d.<a class="code" href="class_generic_document.html#afe94c0abc83a20f2d7dc1ba7677e6238">ParseStream</a>(is);</div><div class="line"></div><div class="line">fclose(fp);</div></div><!-- fragment --><p>与<code>StringStreams</code>不一样，<code><a class="el" href="class_file_read_stream.html" title="File byte stream for input using fread(). ">FileReadStream</a></code>是一个字节流。它不处理编码。若文件并非UTF-8编码，可以把字节流用<code><a class="el" href="class_encoded_input_stream.html" title="Input byte stream wrapper with a statically bound encoding. ">EncodedInputStream</a></code>包装。我们很快会讨论这个问题。</p>
<p>除了读取文件，使用者也可以使用<code><a class="el" href="class_file_read_stream.html" title="File byte stream for input using fread(). ">FileReadStream</a></code>来读取<code>stdin</code>。</p>
<h2><a class="anchor" id="FileWriteStream"></a>
FileWriteStream (Output)</h2>
<p><code><a class="el" href="class_file_write_stream.html" title="Wrapper of C file stream for input using fread(). ">FileWriteStream</a></code>是一个含缓冲功能的输出流。它的用法与<code><a class="el" href="class_file_read_stream.html" title="File byte stream for input using fread(). ">FileReadStream</a></code>非常相似。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rapidjson/filewritestream.h&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line"><a class="code" href="class_generic_document.html">Document</a> d;</div><div class="line">d.<a class="code" href="class_generic_document.html#aebd4e7fddd80c1e1174837aee6d2159b">Parse</a>(json);</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;output.json&quot;</span>, <span class="stringliteral">&quot;wb&quot;</span>); <span class="comment">// 非Windows平台使用&quot;w&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> writeBuffer[65536];</div><div class="line"><a class="code" href="class_file_write_stream.html">FileWriteStream</a> os(fp, writeBuffer, <span class="keyword">sizeof</span>(writeBuffer));</div><div class="line"></div><div class="line"><a class="code" href="class_writer.html">Writer&lt;FileWriteStream&gt;</a> writer(os);</div><div class="line">d.Accept(writer);</div><div class="line"></div><div class="line">fclose(fp);</div></div><!-- fragment --><p>它也可以把输出导向<code>stdout</code>。</p>
<h1><a class="anchor" id="EncodedStreams"></a>
Encoded Streams</h1>
<p>编码流（encoded streams）本身不存储JSON，它们是通过包装字节流来提供基本的编码／解码功能。</p>
<p>如上所述，我们可以直接读入UTF-8字节流。然而，UTF-16及UTF-32有字节序（endian）问题。要正确地处理字节序，需要在读取时把字节转换成字符（如对UTF-16使用<code>wchar_t</code>），以及在写入时把字符转换为字节。</p>
<p>除此以外，我们也需要处理<a href="http://en.wikipedia.org/wiki/Byte_order_mark">字节顺序标记（byte order mark, BOM）</a>。当从一个字节流读取时，需要检测BOM，或者仅仅是把存在的BOM消去。当把JSON写入字节流时，也可选择写入BOM。</p>
<p>若一个流的编码在编译期已知，你可使用<code><a class="el" href="class_encoded_input_stream.html" title="Input byte stream wrapper with a statically bound encoding. ">EncodedInputStream</a></code>及<code><a class="el" href="class_encoded_output_stream.html" title="Output byte stream wrapper with statically bound encoding. ">EncodedOutputStream</a></code>。若一个流可能存储UTF-8、UTF-16LE、UTF-16BE、UTF-32LE、UTF-32BE的JSON，并且编码只能在运行时得知，你便可以使用<code><a class="el" href="class_auto_u_t_f_input_stream.html" title="Input stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFInputStream</a></code>及<code><a class="el" href="class_auto_u_t_f_output_stream.html" title="Output stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFOutputStream</a></code>。这些流定义在<code><a class="el" href="encodedstream_8h_source.html">rapidjson/encodedstream.h</a></code>。</p>
<p>注意到，这些编码流可以施于文件以外的流。例如，你可以用编码流包装内存中的文件或自定义的字节流。</p>
<h2><a class="anchor" id="EncodedInputStream"></a>
EncodedInputStream</h2>
<p><code><a class="el" href="class_encoded_input_stream.html" title="Input byte stream wrapper with a statically bound encoding. ">EncodedInputStream</a></code>含两个模板参数。第一个是<code>Encoding</code>类型，例如定义于<code><a class="el" href="encodings_8h_source.html">rapidjson/encodings.h</a></code>的<code><a class="el" href="struct_u_t_f8.html" title="UTF-8 encoding. ">UTF8</a></code>、<code><a class="el" href="struct_u_t_f16_l_e.html" title="UTF-16 little endian encoding. ">UTF16LE</a></code>。第二个参数是被包装的流的类型。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="document_8h.html">rapidjson/document.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;rapidjson/filereadstream.h&quot;</span>   <span class="comment">// FileReadStream</span></div><div class="line"><span class="preprocessor">#include &quot;rapidjson/encodedstream.h&quot;</span>    <span class="comment">// EncodedInputStream</span></div><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;utf16le.json&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span>); <span class="comment">// 非Windows平台使用&quot;r&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> readBuffer[256];</div><div class="line"><a class="code" href="class_file_read_stream.html">FileReadStream</a> bis(fp, readBuffer, <span class="keyword">sizeof</span>(readBuffer));</div><div class="line"></div><div class="line"><a class="code" href="class_encoded_input_stream.html">EncodedInputStream&lt;UTF16LE&lt;&gt;</a>, <a class="code" href="class_file_read_stream.html">FileReadStream</a>&gt; eis(bis);  <span class="comment">// 用eis包装bis</span></div><div class="line"></div><div class="line"><a class="code" href="class_generic_document.html">Document</a> d; <span class="comment">// Document为GenericDocument&lt;UTF8&lt;&gt; &gt; </span></div><div class="line">d.<a class="code" href="class_generic_document.html#afe94c0abc83a20f2d7dc1ba7677e6238">ParseStream</a>&lt;0, <a class="code" href="struct_u_t_f16_l_e.html">UTF16LE&lt;&gt;</a> &gt;(eis);  <span class="comment">// 把UTF-16LE文件解析至内存中的UTF-8</span></div><div class="line"></div><div class="line">fclose(fp);</div></div><!-- fragment --><h2><a class="anchor" id="EncodedOutputStream"></a>
EncodedOutputStream</h2>
<p><code><a class="el" href="class_encoded_output_stream.html" title="Output byte stream wrapper with statically bound encoding. ">EncodedOutputStream</a></code>也是相似的，但它的构造函数有一个<code>bool putBOM</code>参数，用于控制是否在输出字节流写入BOM。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rapidjson/filewritestream.h&quot;</span>  <span class="comment">// FileWriteStream</span></div><div class="line"><span class="preprocessor">#include &quot;rapidjson/encodedstream.h&quot;</span>    <span class="comment">// EncodedOutputStream</span></div><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="class_generic_document.html">Document</a> d;         <span class="comment">// Document为GenericDocument&lt;UTF8&lt;&gt; &gt; </span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;output_utf32le.json&quot;</span>, <span class="stringliteral">&quot;wb&quot;</span>); <span class="comment">// 非Windows平台使用&quot;w&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> writeBuffer[256];</div><div class="line"><a class="code" href="class_file_write_stream.html">FileWriteStream</a> bos(fp, writeBuffer, <span class="keyword">sizeof</span>(writeBuffer));</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> EncodedOutputStream&lt;UTF32LE&lt;&gt;, <a class="code" href="class_file_write_stream.html">FileWriteStream</a>&gt; OutputStream;</div><div class="line">OutputStream eos(bos, <span class="keyword">true</span>);   <span class="comment">// 写入BOM</span></div><div class="line"></div><div class="line"><a class="code" href="class_writer.html">Writer&lt;OutputStream, UTF32LE&lt;&gt;</a>, <a class="code" href="struct_u_t_f8.html">UTF8&lt;&gt;</a>&gt; writer(eos);</div><div class="line">d.Accept(writer);   <span class="comment">// 这里从内存的UTF-8生成UTF32-LE文件</span></div><div class="line"></div><div class="line">fclose(fp);</div></div><!-- fragment --><h2><a class="anchor" id="AutoUTFInputStream"></a>
AutoUTFInputStream</h2>
<p>有时候，应用软件可能需要㲃理所有可支持的JSON编码。<code><a class="el" href="class_auto_u_t_f_input_stream.html" title="Input stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFInputStream</a></code>会先使用BOM来检测编码。若BOM不存在，它便会使用合法JSON的特性来检测。若两种方法都失败，它就会倒退至构造函数提供的UTF类型。</p>
<p>由于字符（编码单元／code unit）可能是8位、16位或32位，<code><a class="el" href="class_auto_u_t_f_input_stream.html" title="Input stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFInputStream</a></code> 需要一个能至少储存32位的字符类型。我们可以使用<code>unsigned</code>作为模板参数：</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="document_8h.html">rapidjson/document.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;rapidjson/filereadstream.h&quot;</span>   <span class="comment">// FileReadStream</span></div><div class="line"><span class="preprocessor">#include &quot;rapidjson/encodedstream.h&quot;</span>    <span class="comment">// AutoUTFInputStream</span></div><div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;any.json&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span>); <span class="comment">// 非Windows平台使用&quot;r&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> readBuffer[256];</div><div class="line"><a class="code" href="class_file_read_stream.html">FileReadStream</a> bis(fp, readBuffer, <span class="keyword">sizeof</span>(readBuffer));</div><div class="line"></div><div class="line"><a class="code" href="class_auto_u_t_f_input_stream.html">AutoUTFInputStream&lt;unsigned, FileReadStream&gt;</a> eis(bis);  <span class="comment">// 用eis包装bis</span></div><div class="line"></div><div class="line"><a class="code" href="class_generic_document.html">Document</a> d;         <span class="comment">// Document为GenericDocument&lt;UTF8&lt;&gt; &gt; </span></div><div class="line">d.<a class="code" href="class_generic_document.html#afe94c0abc83a20f2d7dc1ba7677e6238">ParseStream</a>&lt;0, <a class="code" href="struct_auto_u_t_f.html">AutoUTF&lt;unsigned&gt;</a> &gt;(eis); <span class="comment">// 把任何UTF编码的文件解析至内存中的UTF-8</span></div><div class="line"></div><div class="line">fclose(fp);</div></div><!-- fragment --><p>当要指定流的编码，可使用上面例子中<code>ParseStream()</code>的参数<code><a class="el" href="struct_auto_u_t_f.html" title="Dynamically select encoding according to stream&#39;s runtime-specified UTF encoding type. ">AutoUTF</a>&lt;CharType&gt;</code>。</p>
<p>你可以使用<code>UTFType GetType()</code>去获取UTF类型，并且用<code>HasBOM()</code>检测输入流是否含有BOM。</p>
<h2><a class="anchor" id="AutoUTFOutputStream"></a>
AutoUTFOutputStream</h2>
<p>相似地，要在运行时选择输出的编码，我们可使用<code><a class="el" href="class_auto_u_t_f_output_stream.html" title="Output stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFOutputStream</a></code>。这个类本身并非「自动」。你需要在运行时指定UTF类型，以及是否写入BOM。</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> WriteJSONFile(FILE* fp, UTFType type, <span class="keywordtype">bool</span> putBOM, <span class="keyword">const</span> <a class="code" href="class_generic_document.html">Document</a>&amp; d) {</div><div class="line">    <span class="keywordtype">char</span> writeBuffer[256];</div><div class="line">    <a class="code" href="class_file_write_stream.html">FileWriteStream</a> bos(fp, writeBuffer, <span class="keyword">sizeof</span>(writeBuffer));</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="class_auto_u_t_f_output_stream.html">AutoUTFOutputStream&lt;unsigned, FileWriteStream&gt;</a> OutputStream;</div><div class="line">    OutputStream eos(bos, type, putBOM);</div><div class="line"></div><div class="line">    <a class="code" href="class_writer.html">Writer&lt;OutputStream, UTF8&lt;&gt;</a>, <a class="code" href="struct_auto_u_t_f.html">AutoUTF&lt;&gt;</a> &gt; writer;</div><div class="line">    d.Accept(writer);</div><div class="line">}</div></div><!-- fragment --><p><code><a class="el" href="class_auto_u_t_f_input_stream.html" title="Input stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFInputStream</a></code>／<code><a class="el" href="class_auto_u_t_f_output_stream.html" title="Output stream wrapper with dynamically bound encoding and automatic encoding detection. ">AutoUTFOutputStream</a></code>是比<code><a class="el" href="class_encoded_input_stream.html" title="Input byte stream wrapper with a statically bound encoding. ">EncodedInputStream</a></code>／<code><a class="el" href="class_encoded_output_stream.html" title="Output byte stream wrapper with statically bound encoding. ">EncodedOutputStream</a></code>方便。但前者会产生一点运行期额外开销。</p>
<h1><a class="anchor" id="CustomStream"></a>
Custom Stream</h1>
<p>除了内存／文件流，使用者可创建自行定义适配RapidJSON API的流类。例如，你可以创建网络流、从压缩文件读取的流等等。</p>
<p>RapidJSON利用模板结合不同的类型。只要一个类包含所有所需的接口，就可以作为一个流。流的接合定义在<code><a class="el" href="rapidjson_8h.html" title="common definitions and configuration ">rapidjson/rapidjson.h</a></code>的注释里：</p>
<div class="fragment"><div class="line">concept Stream {</div><div class="line">    <span class="keyword">typename</span> Ch;    </div><div class="line"></div><div class="line">    Ch Peek() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    Ch Take();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> Tell();</div><div class="line"></div><div class="line">    Ch* PutBegin();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Put(Ch c);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Flush();</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> PutEnd(Ch* begin);</div><div class="line">}</div></div><!-- fragment --><p>输入流必须实现<code>Peek()</code>、<code>Take()</code>及<code>Tell()</code>。 输出流必须实现<code>Put()</code>及<code>Flush()</code>。 <code>PutBegin()</code>及<code>PutEnd()</code>是特殊的接口，仅用于原位（*in situ*）解析。一般的流不需实现它们。然而，即使接口不需用于某些流，仍然需要提供空实现，否则会产生编译错误。</p>
<h2><a class="anchor" id="ExampleIStreamWrapper"></a>
Example: istream wrapper</h2>
<p>以下的例子是<code>std::istream</code>的包装类，它只需现3个函数。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>IStreamWrapper {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">char</span> Ch;</div><div class="line"></div><div class="line">    IStreamWrapper(std::istream&amp; is) : is_(is) {</div><div class="line">    }</div><div class="line"></div><div class="line">    Ch Peek()<span class="keyword"> const </span>{ <span class="comment">// 1</span></div><div class="line">        <span class="keywordtype">int</span> c = is_.peek();</div><div class="line">        <span class="keywordflow">return</span> c == std::char_traits&lt;char&gt;::eof() ? <span class="charliteral">&#39;\0&#39;</span> : (Ch)c;</div><div class="line">    }</div><div class="line"></div><div class="line">    Ch Take() { <span class="comment">// 2</span></div><div class="line">        <span class="keywordtype">int</span> c = is_.get();</div><div class="line">        <span class="keywordflow">return</span> c == std::char_traits&lt;char&gt;::eof() ? <span class="charliteral">&#39;\0&#39;</span> : (Ch)c;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> Tell()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (<span class="keywordtype">size_t</span>)is_.tellg(); } <span class="comment">// 3</span></div><div class="line"></div><div class="line">    Ch* PutBegin() { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> 0; }</div><div class="line">    <span class="keywordtype">void</span> Put(Ch) { assert(<span class="keyword">false</span>); }</div><div class="line">    <span class="keywordtype">void</span> Flush() { assert(<span class="keyword">false</span>); }</div><div class="line">    <span class="keywordtype">size_t</span> PutEnd(Ch*) { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> 0; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    IStreamWrapper(<span class="keyword">const</span> IStreamWrapper&amp;);</div><div class="line">    IStreamWrapper&amp; operator=(<span class="keyword">const</span> IStreamWrapper&amp;);</div><div class="line"></div><div class="line">    std::istream&amp; is_;</div><div class="line">};</div></div><!-- fragment --><p>使用者能用它来包装<code>std::stringstream</code>、<code>std::ifstream</code>的实例。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* json = <span class="stringliteral">&quot;[1,2,3,4]&quot;</span>;</div><div class="line">std::stringstream ss(json);</div><div class="line">IStreamWrapper is(ss);</div><div class="line"></div><div class="line"><a class="code" href="class_generic_document.html">Document</a> d;</div><div class="line">d.<a class="code" href="class_generic_document.html#afe94c0abc83a20f2d7dc1ba7677e6238">ParseStream</a>(is);</div></div><!-- fragment --><p>但要注意，由于标准库的内部开销问，此实现的性能可能不如RapidJSON的内存／文件流。</p>
<h2><a class="anchor" id="ExampleOStreamWrapper"></a>
Example: ostream wrapper</h2>
<p>以下的例子是<code>std::istream</code>的包装类，它只需实现2个函数。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>OStreamWrapper {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">char</span> Ch;</div><div class="line"></div><div class="line">    OStreamWrapper(std::ostream&amp; os) : os_(os) {</div><div class="line">    }</div><div class="line"></div><div class="line">    Ch Peek()<span class="keyword"> const </span>{ assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> <span class="charliteral">&#39;\0&#39;</span>; }</div><div class="line">    Ch Take() { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> <span class="charliteral">&#39;\0&#39;</span>; }</div><div class="line">    <span class="keywordtype">size_t</span> Tell()<span class="keyword"> const </span>{  }</div><div class="line"></div><div class="line">    Ch* PutBegin() { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> 0; }</div><div class="line">    <span class="keywordtype">void</span> Put(Ch c) { os_.put(c); }                  <span class="comment">// 1</span></div><div class="line">    <span class="keywordtype">void</span> Flush() { os_.flush(); }                   <span class="comment">// 2</span></div><div class="line">    <span class="keywordtype">size_t</span> PutEnd(Ch*) { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> 0; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    OStreamWrapper(<span class="keyword">const</span> OStreamWrapper&amp;);</div><div class="line">    OStreamWrapper&amp; operator=(<span class="keyword">const</span> OStreamWrapper&amp;);</div><div class="line"></div><div class="line">    std::ostream&amp; os_;</div><div class="line">};</div></div><!-- fragment --><p>使用者能用它来包装<code>std::stringstream</code>、<code>std::ofstream</code>的实例。</p>
<div class="fragment"><div class="line"><a class="code" href="class_generic_document.html">Document</a> d;</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">std::stringstream ss;</div><div class="line">OSStreamWrapper os(ss);</div><div class="line"></div><div class="line"><a class="code" href="class_writer.html">Writer&lt;OStreamWrapper&gt;</a> writer(os);</div><div class="line">d.Accept(writer);</div></div><!-- fragment --><p>但要注意，由于标准库的内部开销问，此实现的性能可能不如RapidJSON的内存／文件流。</p>
<h1><a class="anchor" id="Summary"></a>
Summary</h1>
<p>本节描述了RapidJSON提供的各种流的类。内存流很简单。若JSON存储在文件中，文件流可减少JSON解析及生成所需的内存量。编码流在字节流和字符流之间作转换。最后，使用者可使用一个简单接口创建自定义的流。 </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
