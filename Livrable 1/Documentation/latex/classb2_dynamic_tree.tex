\hypertarget{classb2_dynamic_tree}{}\section{b2\+Dynamic\+Tree Class Reference}
\label{classb2_dynamic_tree}\index{b2\+Dynamic\+Tree@{b2\+Dynamic\+Tree}}


{\ttfamily \#include $<$b2\+Dynamic\+Tree.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classb2_dynamic_tree_a8af64cf6a1566fa4c5b5c9683bd937d9}{b2\+Dynamic\+Tree} ()\hypertarget{classb2_dynamic_tree_a8af64cf6a1566fa4c5b5c9683bd937d9}{}\label{classb2_dynamic_tree_a8af64cf6a1566fa4c5b5c9683bd937d9}

\begin{DoxyCompactList}\small\item\em Constructing the tree initializes the node pool. \end{DoxyCompactList}\item 
\hyperlink{classb2_dynamic_tree_a9060565fc63b4dd87d9560775c076786}{$\sim$b2\+Dynamic\+Tree} ()\hypertarget{classb2_dynamic_tree_a9060565fc63b4dd87d9560775c076786}{}\label{classb2_dynamic_tree_a9060565fc63b4dd87d9560775c076786}

\begin{DoxyCompactList}\small\item\em Destroy the tree, freeing the node pool. \end{DoxyCompactList}\item 
int32 \hyperlink{classb2_dynamic_tree_ae44676f12977dada46037da47fc7ffbf}{Create\+Proxy} (const \hyperlink{structb2_a_a_b_b}{b2\+A\+A\+BB} \&aabb, void $\ast$user\+Data)\hypertarget{classb2_dynamic_tree_ae44676f12977dada46037da47fc7ffbf}{}\label{classb2_dynamic_tree_ae44676f12977dada46037da47fc7ffbf}

\begin{DoxyCompactList}\small\item\em Create a proxy. Provide a tight fitting A\+A\+BB and a user\+Data pointer. \end{DoxyCompactList}\item 
void \hyperlink{classb2_dynamic_tree_a62aa451e7d7fe029818dd05f76ea9cdc}{Destroy\+Proxy} (int32 proxy\+Id)\hypertarget{classb2_dynamic_tree_a62aa451e7d7fe029818dd05f76ea9cdc}{}\label{classb2_dynamic_tree_a62aa451e7d7fe029818dd05f76ea9cdc}

\begin{DoxyCompactList}\small\item\em Destroy a proxy. This asserts if the id is invalid. \end{DoxyCompactList}\item 
bool \hyperlink{classb2_dynamic_tree_a7748252811f3c575015931399cbe4daa}{Move\+Proxy} (int32 proxy\+Id, const \hyperlink{structb2_a_a_b_b}{b2\+A\+A\+BB} \&aabb1, const \hyperlink{structb2_vec2}{b2\+Vec2} \&displacement)
\item 
void $\ast$ \hyperlink{classb2_dynamic_tree_a44ab57dce3c42b0a5847a64e489a71ce}{Get\+User\+Data} (int32 proxy\+Id) const 
\item 
const \hyperlink{structb2_a_a_b_b}{b2\+A\+A\+BB} \& \hyperlink{classb2_dynamic_tree_adf4676b1c34a57b4451bcbeaebe65687}{Get\+Fat\+A\+A\+BB} (int32 proxy\+Id) const \hypertarget{classb2_dynamic_tree_adf4676b1c34a57b4451bcbeaebe65687}{}\label{classb2_dynamic_tree_adf4676b1c34a57b4451bcbeaebe65687}

\begin{DoxyCompactList}\small\item\em Get the fat A\+A\+BB for a proxy. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{classb2_dynamic_tree_adf70aee89b4692fc79d65b1f54308585}{Query} (T $\ast$callback, const \hyperlink{structb2_a_a_b_b}{b2\+A\+A\+BB} \&aabb) const 
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{classb2_dynamic_tree_abd7a5c6a5bc109dbbdb0ec3aae039648}{Ray\+Cast} (T $\ast$callback, const \hyperlink{structb2_ray_cast_input}{b2\+Ray\+Cast\+Input} \&input) const 
\item 
void \hyperlink{classb2_dynamic_tree_abfac96c615b08406cba3e53b39800f1c}{Validate} () const \hypertarget{classb2_dynamic_tree_abfac96c615b08406cba3e53b39800f1c}{}\label{classb2_dynamic_tree_abfac96c615b08406cba3e53b39800f1c}

\begin{DoxyCompactList}\small\item\em Validate this tree. For testing. \end{DoxyCompactList}\item 
int32 \hyperlink{classb2_dynamic_tree_add7e09cdf279e7c0031da9dfd4cdf4db}{Get\+Height} () const 
\item 
int32 \hyperlink{classb2_dynamic_tree_ae02c45d1a68b42e59d170438ddbb7977}{Get\+Max\+Balance} () const 
\item 
float32 \hyperlink{classb2_dynamic_tree_ad78282a720c451e032b43c34cba02f1a}{Get\+Area\+Ratio} () const \hypertarget{classb2_dynamic_tree_ad78282a720c451e032b43c34cba02f1a}{}\label{classb2_dynamic_tree_ad78282a720c451e032b43c34cba02f1a}

\begin{DoxyCompactList}\small\item\em Get the ratio of the sum of the node areas to the root area. \end{DoxyCompactList}\item 
void \hyperlink{classb2_dynamic_tree_abd146017cfec1cf5ea7b87331f30a3ff}{Rebuild\+Bottom\+Up} ()\hypertarget{classb2_dynamic_tree_abd146017cfec1cf5ea7b87331f30a3ff}{}\label{classb2_dynamic_tree_abd146017cfec1cf5ea7b87331f30a3ff}

\begin{DoxyCompactList}\small\item\em Build an optimal tree. Very expensive. For testing. \end{DoxyCompactList}\item 
void \hyperlink{classb2_dynamic_tree_af37ddfed6a5da97d5a78b09918d19ceb}{Shift\+Origin} (const \hyperlink{structb2_vec2}{b2\+Vec2} \&new\+Origin)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
int32 {\bfseries Allocate\+Node} ()\hypertarget{classb2_dynamic_tree_a975879e87073cfddbc6a988f0d426553}{}\label{classb2_dynamic_tree_a975879e87073cfddbc6a988f0d426553}

\item 
void {\bfseries Free\+Node} (int32 node)\hypertarget{classb2_dynamic_tree_a87f1f5d9f4ff97b420300b6ee642ec92}{}\label{classb2_dynamic_tree_a87f1f5d9f4ff97b420300b6ee642ec92}

\item 
void {\bfseries Insert\+Leaf} (int32 node)\hypertarget{classb2_dynamic_tree_a068fd3f29465fb6aaabbfdd6a70e6058}{}\label{classb2_dynamic_tree_a068fd3f29465fb6aaabbfdd6a70e6058}

\item 
void {\bfseries Remove\+Leaf} (int32 node)\hypertarget{classb2_dynamic_tree_a79bde2ff0a8b53b236865fdffebbd030}{}\label{classb2_dynamic_tree_a79bde2ff0a8b53b236865fdffebbd030}

\item 
int32 {\bfseries Balance} (int32 index)\hypertarget{classb2_dynamic_tree_aad4716f3bd40e60ba0624c75f39843fd}{}\label{classb2_dynamic_tree_aad4716f3bd40e60ba0624c75f39843fd}

\item 
int32 {\bfseries Compute\+Height} () const \hypertarget{classb2_dynamic_tree_a2b2ebfdb68cf8ee392c0f6a154f2b927}{}\label{classb2_dynamic_tree_a2b2ebfdb68cf8ee392c0f6a154f2b927}

\item 
int32 {\bfseries Compute\+Height} (int32 node\+Id) const \hypertarget{classb2_dynamic_tree_af9e3afb3381e4e4985e2dc7c42de078a}{}\label{classb2_dynamic_tree_af9e3afb3381e4e4985e2dc7c42de078a}

\item 
void {\bfseries Validate\+Structure} (int32 index) const \hypertarget{classb2_dynamic_tree_a8b3b8e2996d8f193d76cc4e3984b5155}{}\label{classb2_dynamic_tree_a8b3b8e2996d8f193d76cc4e3984b5155}

\item 
void {\bfseries Validate\+Metrics} (int32 index) const \hypertarget{classb2_dynamic_tree_afd80c61809ae0dde0fdad106f7f3f473}{}\label{classb2_dynamic_tree_afd80c61809ae0dde0fdad106f7f3f473}

\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
int32 {\bfseries m\+\_\+root}\hypertarget{classb2_dynamic_tree_a336705eb2059313288e73de8da59b1a9}{}\label{classb2_dynamic_tree_a336705eb2059313288e73de8da59b1a9}

\item 
\hyperlink{structb2_tree_node}{b2\+Tree\+Node} $\ast$ {\bfseries m\+\_\+nodes}\hypertarget{classb2_dynamic_tree_a16ca7b850396a549eb494ed2f1eb5e5c}{}\label{classb2_dynamic_tree_a16ca7b850396a549eb494ed2f1eb5e5c}

\item 
int32 {\bfseries m\+\_\+node\+Count}\hypertarget{classb2_dynamic_tree_a7532c57eae4d8e04920dc8c9b14665af}{}\label{classb2_dynamic_tree_a7532c57eae4d8e04920dc8c9b14665af}

\item 
int32 {\bfseries m\+\_\+node\+Capacity}\hypertarget{classb2_dynamic_tree_a5b54249f52aee1de21b862ac060eccf2}{}\label{classb2_dynamic_tree_a5b54249f52aee1de21b862ac060eccf2}

\item 
int32 {\bfseries m\+\_\+free\+List}\hypertarget{classb2_dynamic_tree_abacc1866e2f5e5fb5e95d69592a4193a}{}\label{classb2_dynamic_tree_abacc1866e2f5e5fb5e95d69592a4193a}

\item 
uint32 \hyperlink{classb2_dynamic_tree_ab68ffe92575c26e5d3099d8ed050e188}{m\+\_\+path}\hypertarget{classb2_dynamic_tree_ab68ffe92575c26e5d3099d8ed050e188}{}\label{classb2_dynamic_tree_ab68ffe92575c26e5d3099d8ed050e188}

\begin{DoxyCompactList}\small\item\em This is used to incrementally traverse the tree for re-\/balancing. \end{DoxyCompactList}\item 
int32 {\bfseries m\+\_\+insertion\+Count}\hypertarget{classb2_dynamic_tree_a4657cf0c95a523da397094e5e6943f17}{}\label{classb2_dynamic_tree_a4657cf0c95a523da397094e5e6943f17}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
A dynamic A\+A\+BB tree broad-\/phase, inspired by Nathanael Presson\textquotesingle{}s bt\+Dbvt. A dynamic tree arranges data in a binary tree to accelerate queries such as volume queries and ray casts. Leafs are proxies with an A\+A\+BB. In the tree we expand the proxy A\+A\+BB by b2\+\_\+fat\+A\+A\+B\+B\+Factor so that the proxy A\+A\+BB is bigger than the client object. This allows the client object to move by small amounts without triggering a tree update.

Nodes are pooled and relocatable, so we use node indices rather than pointers. 

\subsection{Member Function Documentation}
\index{b2\+Dynamic\+Tree@{b2\+Dynamic\+Tree}!Get\+Height@{Get\+Height}}
\index{Get\+Height@{Get\+Height}!b2\+Dynamic\+Tree@{b2\+Dynamic\+Tree}}
\subsubsection[{\texorpdfstring{Get\+Height() const }{GetHeight() const }}]{\setlength{\rightskip}{0pt plus 5cm}int32 b2\+Dynamic\+Tree\+::\+Get\+Height (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classb2_dynamic_tree_add7e09cdf279e7c0031da9dfd4cdf4db}{}\label{classb2_dynamic_tree_add7e09cdf279e7c0031da9dfd4cdf4db}
Compute the height of the binary tree in O(\+N) time. Should not be called often. \index{b2\+Dynamic\+Tree@{b2\+Dynamic\+Tree}!Get\+Max\+Balance@{Get\+Max\+Balance}}
\index{Get\+Max\+Balance@{Get\+Max\+Balance}!b2\+Dynamic\+Tree@{b2\+Dynamic\+Tree}}
\subsubsection[{\texorpdfstring{Get\+Max\+Balance() const }{GetMaxBalance() const }}]{\setlength{\rightskip}{0pt plus 5cm}int32 b2\+Dynamic\+Tree\+::\+Get\+Max\+Balance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classb2_dynamic_tree_ae02c45d1a68b42e59d170438ddbb7977}{}\label{classb2_dynamic_tree_ae02c45d1a68b42e59d170438ddbb7977}
Get the maximum balance of an node in the tree. The balance is the difference in height of the two children of a node. \index{b2\+Dynamic\+Tree@{b2\+Dynamic\+Tree}!Get\+User\+Data@{Get\+User\+Data}}
\index{Get\+User\+Data@{Get\+User\+Data}!b2\+Dynamic\+Tree@{b2\+Dynamic\+Tree}}
\subsubsection[{\texorpdfstring{Get\+User\+Data(int32 proxy\+Id) const }{GetUserData(int32 proxyId) const }}]{\setlength{\rightskip}{0pt plus 5cm}void $\ast$ b2\+Dynamic\+Tree\+::\+Get\+User\+Data (
\begin{DoxyParamCaption}
\item[{int32}]{proxy\+Id}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classb2_dynamic_tree_a44ab57dce3c42b0a5847a64e489a71ce}{}\label{classb2_dynamic_tree_a44ab57dce3c42b0a5847a64e489a71ce}
Get proxy user data. \begin{DoxyReturn}{Returns}
the proxy user data or 0 if the id is invalid. 
\end{DoxyReturn}
\index{b2\+Dynamic\+Tree@{b2\+Dynamic\+Tree}!Move\+Proxy@{Move\+Proxy}}
\index{Move\+Proxy@{Move\+Proxy}!b2\+Dynamic\+Tree@{b2\+Dynamic\+Tree}}
\subsubsection[{\texorpdfstring{Move\+Proxy(int32 proxy\+Id, const b2\+A\+A\+B\+B \&aabb1, const b2\+Vec2 \&displacement)}{MoveProxy(int32 proxyId, const b2AABB &aabb1, const b2Vec2 &displacement)}}]{\setlength{\rightskip}{0pt plus 5cm}bool b2\+Dynamic\+Tree\+::\+Move\+Proxy (
\begin{DoxyParamCaption}
\item[{int32}]{proxy\+Id, }
\item[{const {\bf b2\+A\+A\+BB} \&}]{aabb1, }
\item[{const {\bf b2\+Vec2} \&}]{displacement}
\end{DoxyParamCaption}
)}\hypertarget{classb2_dynamic_tree_a7748252811f3c575015931399cbe4daa}{}\label{classb2_dynamic_tree_a7748252811f3c575015931399cbe4daa}
Move a proxy with a swepted A\+A\+BB. If the proxy has moved outside of its fattened A\+A\+BB, then the proxy is removed from the tree and re-\/inserted. Otherwise the function returns immediately. \begin{DoxyReturn}{Returns}
true if the proxy was re-\/inserted. 
\end{DoxyReturn}
\index{b2\+Dynamic\+Tree@{b2\+Dynamic\+Tree}!Query@{Query}}
\index{Query@{Query}!b2\+Dynamic\+Tree@{b2\+Dynamic\+Tree}}
\subsubsection[{\texorpdfstring{Query(\+T $\ast$callback, const b2\+A\+A\+B\+B \&aabb) const }{Query(T *callback, const b2AABB &aabb) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ void b2\+Dynamic\+Tree\+::\+Query (
\begin{DoxyParamCaption}
\item[{T $\ast$}]{callback, }
\item[{const {\bf b2\+A\+A\+BB} \&}]{aabb}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classb2_dynamic_tree_adf70aee89b4692fc79d65b1f54308585}{}\label{classb2_dynamic_tree_adf70aee89b4692fc79d65b1f54308585}
Query an A\+A\+BB for overlapping proxies. The callback class is called for each proxy that overlaps the supplied A\+A\+BB. \index{b2\+Dynamic\+Tree@{b2\+Dynamic\+Tree}!Ray\+Cast@{Ray\+Cast}}
\index{Ray\+Cast@{Ray\+Cast}!b2\+Dynamic\+Tree@{b2\+Dynamic\+Tree}}
\subsubsection[{\texorpdfstring{Ray\+Cast(\+T $\ast$callback, const b2\+Ray\+Cast\+Input \&input) const }{RayCast(T *callback, const b2RayCastInput &input) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ void b2\+Dynamic\+Tree\+::\+Ray\+Cast (
\begin{DoxyParamCaption}
\item[{T $\ast$}]{callback, }
\item[{const {\bf b2\+Ray\+Cast\+Input} \&}]{input}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classb2_dynamic_tree_abd7a5c6a5bc109dbbdb0ec3aae039648}{}\label{classb2_dynamic_tree_abd7a5c6a5bc109dbbdb0ec3aae039648}
Ray-\/cast against the proxies in the tree. This relies on the callback to perform a exact ray-\/cast in the case were the proxy contains a shape. The callback also performs the any collision filtering. This has performance roughly equal to k $\ast$ log(n), where k is the number of collisions and n is the number of proxies in the tree. 
\begin{DoxyParams}{Parameters}
{\em input} & the ray-\/cast input data. The ray extends from p1 to p1 + max\+Fraction $\ast$ (p2 -\/ p1). \\
\hline
{\em callback} & a callback class that is called for each proxy that is hit by the ray. \\
\hline
\end{DoxyParams}
\index{b2\+Dynamic\+Tree@{b2\+Dynamic\+Tree}!Shift\+Origin@{Shift\+Origin}}
\index{Shift\+Origin@{Shift\+Origin}!b2\+Dynamic\+Tree@{b2\+Dynamic\+Tree}}
\subsubsection[{\texorpdfstring{Shift\+Origin(const b2\+Vec2 \&new\+Origin)}{ShiftOrigin(const b2Vec2 &newOrigin)}}]{\setlength{\rightskip}{0pt plus 5cm}void b2\+Dynamic\+Tree\+::\+Shift\+Origin (
\begin{DoxyParamCaption}
\item[{const {\bf b2\+Vec2} \&}]{new\+Origin}
\end{DoxyParamCaption}
)}\hypertarget{classb2_dynamic_tree_af37ddfed6a5da97d5a78b09918d19ceb}{}\label{classb2_dynamic_tree_af37ddfed6a5da97d5a78b09918d19ceb}
Shift the world origin. Useful for large worlds. The shift formula is\+: position -\/= new\+Origin 
\begin{DoxyParams}{Parameters}
{\em new\+Origin} & the new origin with respect to the old origin \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Commun/\+Externe/\+Box2\+D/include/\+Box2\+D/\+Collision/b2\+Dynamic\+Tree.\+h\end{DoxyCompactItemize}
