\hypertarget{structai_importer_desc}{}\section{ai\+Importer\+Desc Struct Reference}
\label{structai_importer_desc}\index{ai\+Importer\+Desc@{ai\+Importer\+Desc}}


{\ttfamily \#include $<$importerdesc.\+h$>$}

\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \hyperlink{structai_importer_desc_a2a9d5fd818c01bba1a0a782722ab9495}{m\+Name}
\item 
const char $\ast$ \hyperlink{structai_importer_desc_a8e050453324b1e855701c7c082c1b24b}{m\+Author}
\item 
const char $\ast$ \hyperlink{structai_importer_desc_a53bf0ecb36ce0b97018b4b6bd2748f02}{m\+Maintainer}
\item 
const char $\ast$ \hyperlink{structai_importer_desc_a2d8ad562f6c18ee9e8bfdb2da4871118}{m\+Comments}
\item 
unsigned int \hyperlink{structai_importer_desc_a9939db58b9f95a537f9f5a749524b6b2}{m\+Flags}
\item 
unsigned int \hyperlink{structai_importer_desc_aee34d348f522807f0a36607664e92a57}{m\+Min\+Major}
\item 
unsigned int {\bfseries m\+Min\+Minor}\hypertarget{structai_importer_desc_adb265dee32c6533234c45638df66ddab}{}\label{structai_importer_desc_adb265dee32c6533234c45638df66ddab}

\item 
unsigned int \hyperlink{structai_importer_desc_a9d33eac3be20f7f4630f838a228ada63}{m\+Max\+Major}
\item 
unsigned int {\bfseries m\+Max\+Minor}\hypertarget{structai_importer_desc_ae4c60eec7020af836b23537148f47f83}{}\label{structai_importer_desc_ae4c60eec7020af836b23537148f47f83}

\item 
const char $\ast$ \hyperlink{structai_importer_desc_a074bd688ffd15d7f4df32e794111a413}{m\+File\+Extensions}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Meta information about a particular importer. Importers need to fill this structure, but they can freely decide how talkative they are. A common use case for loader meta info is a user interface in which the user can choose between various import/export file formats. Building such an UI by hand means a lot of maintenance as importers/exporters are added to \hyperlink{namespace_assimp}{Assimp}, so it might be useful to have a common mechanism to query some rough importer characteristics. 

\subsection{Member Data Documentation}
\index{ai\+Importer\+Desc@{ai\+Importer\+Desc}!m\+Author@{m\+Author}}
\index{m\+Author@{m\+Author}!ai\+Importer\+Desc@{ai\+Importer\+Desc}}
\subsubsection[{\texorpdfstring{m\+Author}{mAuthor}}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ ai\+Importer\+Desc\+::m\+Author}\hypertarget{structai_importer_desc_a8e050453324b1e855701c7c082c1b24b}{}\label{structai_importer_desc_a8e050453324b1e855701c7c082c1b24b}
Original author (left blank if unknown or whole assimp team) \index{ai\+Importer\+Desc@{ai\+Importer\+Desc}!m\+Comments@{m\+Comments}}
\index{m\+Comments@{m\+Comments}!ai\+Importer\+Desc@{ai\+Importer\+Desc}}
\subsubsection[{\texorpdfstring{m\+Comments}{mComments}}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ ai\+Importer\+Desc\+::m\+Comments}\hypertarget{structai_importer_desc_a2d8ad562f6c18ee9e8bfdb2da4871118}{}\label{structai_importer_desc_a2d8ad562f6c18ee9e8bfdb2da4871118}
Implementation comments, i.\+e. unimplemented features \index{ai\+Importer\+Desc@{ai\+Importer\+Desc}!m\+File\+Extensions@{m\+File\+Extensions}}
\index{m\+File\+Extensions@{m\+File\+Extensions}!ai\+Importer\+Desc@{ai\+Importer\+Desc}}
\subsubsection[{\texorpdfstring{m\+File\+Extensions}{mFileExtensions}}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ ai\+Importer\+Desc\+::m\+File\+Extensions}\hypertarget{structai_importer_desc_a074bd688ffd15d7f4df32e794111a413}{}\label{structai_importer_desc_a074bd688ffd15d7f4df32e794111a413}
List of file extensions this importer can handle. List entries are separated by space characters. All entries are lower case without a leading dot (i.\+e. \char`\"{}xml dae\char`\"{} would be a valid value. Note that multiple importers may respond to the same file extension -\/ assimp calls all importers in the order in which they are registered and each importer gets the opportunity to load the file until one importer \char`\"{}claims\char`\"{} the file. Apart from file extension checks, importers typically use other methods to quickly reject files (i.\+e. magic words) so this does not mean that common or generic file extensions such as X\+ML would be tediously slow. \index{ai\+Importer\+Desc@{ai\+Importer\+Desc}!m\+Flags@{m\+Flags}}
\index{m\+Flags@{m\+Flags}!ai\+Importer\+Desc@{ai\+Importer\+Desc}}
\subsubsection[{\texorpdfstring{m\+Flags}{mFlags}}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int ai\+Importer\+Desc\+::m\+Flags}\hypertarget{structai_importer_desc_a9939db58b9f95a537f9f5a749524b6b2}{}\label{structai_importer_desc_a9939db58b9f95a537f9f5a749524b6b2}
Any combination of the \#ai\+Loader\+Flags enumerated values. These flags indicate some characteristics common to many importers. \index{ai\+Importer\+Desc@{ai\+Importer\+Desc}!m\+Maintainer@{m\+Maintainer}}
\index{m\+Maintainer@{m\+Maintainer}!ai\+Importer\+Desc@{ai\+Importer\+Desc}}
\subsubsection[{\texorpdfstring{m\+Maintainer}{mMaintainer}}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ ai\+Importer\+Desc\+::m\+Maintainer}\hypertarget{structai_importer_desc_a53bf0ecb36ce0b97018b4b6bd2748f02}{}\label{structai_importer_desc_a53bf0ecb36ce0b97018b4b6bd2748f02}
Current maintainer, left blank if the author maintains \index{ai\+Importer\+Desc@{ai\+Importer\+Desc}!m\+Max\+Major@{m\+Max\+Major}}
\index{m\+Max\+Major@{m\+Max\+Major}!ai\+Importer\+Desc@{ai\+Importer\+Desc}}
\subsubsection[{\texorpdfstring{m\+Max\+Major}{mMaxMajor}}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int ai\+Importer\+Desc\+::m\+Max\+Major}\hypertarget{structai_importer_desc_a9d33eac3be20f7f4630f838a228ada63}{}\label{structai_importer_desc_a9d33eac3be20f7f4630f838a228ada63}
Maximum format version that can be loaded im major.\+minor format, both are set to 0 if there is either no version scheme or if the loader doesn\textquotesingle{}t care. Loaders that expect to be forward-\/compatible to potential future format versions should indicate zero, otherwise they should specify the current maximum version. \index{ai\+Importer\+Desc@{ai\+Importer\+Desc}!m\+Min\+Major@{m\+Min\+Major}}
\index{m\+Min\+Major@{m\+Min\+Major}!ai\+Importer\+Desc@{ai\+Importer\+Desc}}
\subsubsection[{\texorpdfstring{m\+Min\+Major}{mMinMajor}}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int ai\+Importer\+Desc\+::m\+Min\+Major}\hypertarget{structai_importer_desc_aee34d348f522807f0a36607664e92a57}{}\label{structai_importer_desc_aee34d348f522807f0a36607664e92a57}
Minimum format version that can be loaded im major.\+minor format, both are set to 0 if there is either no version scheme or if the loader doesn\textquotesingle{}t care. \index{ai\+Importer\+Desc@{ai\+Importer\+Desc}!m\+Name@{m\+Name}}
\index{m\+Name@{m\+Name}!ai\+Importer\+Desc@{ai\+Importer\+Desc}}
\subsubsection[{\texorpdfstring{m\+Name}{mName}}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ ai\+Importer\+Desc\+::m\+Name}\hypertarget{structai_importer_desc_a2a9d5fd818c01bba1a0a782722ab9495}{}\label{structai_importer_desc_a2a9d5fd818c01bba1a0a782722ab9495}
Full name of the importer (i.\+e. Blender3D importer) 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Commun/\+Externe/assimp/include/\hyperlink{importerdesc_8h}{importerdesc.\+h}\end{DoxyCompactItemize}
