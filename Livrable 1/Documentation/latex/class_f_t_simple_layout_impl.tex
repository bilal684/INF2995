\hypertarget{class_f_t_simple_layout_impl}{}\section{F\+T\+Simple\+Layout\+Impl Class Reference}
\label{class_f_t_simple_layout_impl}\index{F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}}
Inheritance diagram for F\+T\+Simple\+Layout\+Impl\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_f_t_simple_layout_impl}
\end{center}
\end{figure}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual F\+T\+B\+Box {\bfseries B\+Box} (const char $\ast$string, const int len, F\+T\+Point position)\hypertarget{class_f_t_simple_layout_impl_a6cdedbc1045881dcb3ddedea054a7987}{}\label{class_f_t_simple_layout_impl_a6cdedbc1045881dcb3ddedea054a7987}

\item 
virtual F\+T\+B\+Box {\bfseries B\+Box} (const wchar\+\_\+t $\ast$string, const int len, F\+T\+Point position)\hypertarget{class_f_t_simple_layout_impl_a682650a15a67eb182b2de9e7001875cb}{}\label{class_f_t_simple_layout_impl_a682650a15a67eb182b2de9e7001875cb}

\item 
virtual void {\bfseries Render} (const char $\ast$string, const int len, F\+T\+Point position, int render\+Mode)\hypertarget{class_f_t_simple_layout_impl_abfe85f44b3d4a2f8691b5e11ab26828a}{}\label{class_f_t_simple_layout_impl_abfe85f44b3d4a2f8691b5e11ab26828a}

\item 
virtual void {\bfseries Render} (const wchar\+\_\+t $\ast$string, const int len, F\+T\+Point position, int render\+Mode)\hypertarget{class_f_t_simple_layout_impl_ac69f1a3cdac5e6dd692b547df3f77825}{}\label{class_f_t_simple_layout_impl_ac69f1a3cdac5e6dd692b547df3f77825}

\item 
virtual void \hyperlink{class_f_t_simple_layout_impl_abdbd064c650f1e17d2bd3139536aff47}{Render\+Space} (const char $\ast$string, const int len, F\+T\+Point position, int render\+Mode, const float extra\+Space)
\item 
virtual void \hyperlink{class_f_t_simple_layout_impl_a6b5334d053e9c79dd459f8b88c0e60a4}{Render\+Space} (const wchar\+\_\+t $\ast$string, const int len, F\+T\+Point position, int render\+Mode, const float extra\+Space)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{class_f_t_simple_layout_impl_aefdfcffcfca03e0139db7e21c968f7c5}{Wrap\+Text} (const char $\ast$buf, const int len, F\+T\+Point position, int render\+Mode, F\+T\+B\+Box $\ast$bounds)
\item 
virtual void \hyperlink{class_f_t_simple_layout_impl_a344c5b35b3b02da0deea00b337017389}{Wrap\+Text} (const wchar\+\_\+t $\ast$buf, const int len, F\+T\+Point position, int render\+Mode, F\+T\+B\+Box $\ast$bounds)
\item 
void \hyperlink{class_f_t_simple_layout_impl_ab08c29c22c870026c0de687398302c08}{Output\+Wrapped} (const char $\ast$buf, const int len, F\+T\+Point position, int render\+Mode, const float Remaining\+Width, F\+T\+B\+Box $\ast$bounds)
\item 
void \hyperlink{class_f_t_simple_layout_impl_a8a0e01a58af988be392daad3187f1139}{Output\+Wrapped} (const wchar\+\_\+t $\ast$buf, const int len, F\+T\+Point position, int render\+Mode, const float Remaining\+Width, F\+T\+B\+Box $\ast$bounds)
\item 
{\footnotesize template$<$typename T $>$ }\\F\+T\+B\+Box {\bfseries B\+BoxI} (const T $\ast$string, const int len, F\+T\+Point position)\hypertarget{class_f_t_simple_layout_impl_a104961c1909af9520dc1b320ef9b7dd1}{}\label{class_f_t_simple_layout_impl_a104961c1909af9520dc1b320ef9b7dd1}

\item 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries RenderI} (const T $\ast$string, const int len, F\+T\+Point position, int render\+Mode)\hypertarget{class_f_t_simple_layout_impl_a37fb21ef3b7979d5179acaa483f0e00e}{}\label{class_f_t_simple_layout_impl_a37fb21ef3b7979d5179acaa483f0e00e}

\item 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries Render\+SpaceI} (const T $\ast$string, const int len, F\+T\+Point position, int render\+Mode, const float extra\+Space)\hypertarget{class_f_t_simple_layout_impl_a0264621b2b6a40ffea0bc56828bd4c33}{}\label{class_f_t_simple_layout_impl_a0264621b2b6a40ffea0bc56828bd4c33}

\item 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries Wrap\+TextI} (const T $\ast$buf, const int len, F\+T\+Point position, int render\+Mode, F\+T\+B\+Box $\ast$bounds)\hypertarget{class_f_t_simple_layout_impl_ad34461418ac61f886e93260fea978e00}{}\label{class_f_t_simple_layout_impl_ad34461418ac61f886e93260fea978e00}

\item 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries Output\+WrappedI} (const T $\ast$buf, const int len, F\+T\+Point position, int render\+Mode, const float Remaining\+Width, F\+T\+B\+Box $\ast$bounds)\hypertarget{class_f_t_simple_layout_impl_a17a19357f263f81a08b0357f2fbacb9e}{}\label{class_f_t_simple_layout_impl_a17a19357f263f81a08b0357f2fbacb9e}

\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
F\+T\+Font $\ast$ \hyperlink{class_f_t_simple_layout_impl_af77c6b00911959673e6e45275bccd128}{current\+Font}
\item 
float \hyperlink{class_f_t_simple_layout_impl_a46da513a479522dd9fe9ab752a761b3e}{line\+Length}
\item 
F\+T\+G\+L\+::\+Text\+Alignment \hyperlink{class_f_t_simple_layout_impl_a0f0edb7cdf27a22fe66f635c56aa0dbd}{alignment}
\item 
float \hyperlink{class_f_t_simple_layout_impl_a0afb3dda6e096069602a8df941293605}{line\+Spacing}
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class {\bfseries F\+T\+Simple\+Layout}\hypertarget{class_f_t_simple_layout_impl_ae27eaa779922d14c8eb0f476456c7099}{}\label{class_f_t_simple_layout_impl_ae27eaa779922d14c8eb0f476456c7099}

\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Member Function Documentation}
\index{F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}!Output\+Wrapped@{Output\+Wrapped}}
\index{Output\+Wrapped@{Output\+Wrapped}!F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}}
\subsubsection[{\texorpdfstring{Output\+Wrapped(const char $\ast$buf, const int len, F\+T\+Point position, int render\+Mode, const float Remaining\+Width, F\+T\+B\+Box $\ast$bounds)}{OutputWrapped(const char *buf, const int len, FTPoint position, int renderMode, const float RemainingWidth, FTBBox *bounds)}}]{\setlength{\rightskip}{0pt plus 5cm}void F\+T\+Simple\+Layout\+Impl\+::\+Output\+Wrapped (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{buf, }
\item[{const int}]{len, }
\item[{F\+T\+Point}]{position, }
\item[{int}]{render\+Mode, }
\item[{const float}]{Remaining\+Width, }
\item[{F\+T\+B\+Box $\ast$}]{bounds}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_f_t_simple_layout_impl_ab08c29c22c870026c0de687398302c08}{}\label{class_f_t_simple_layout_impl_ab08c29c22c870026c0de687398302c08}
A helper method used by Wrap\+Text to either output the text or compute it\textquotesingle{}s bounds.


\begin{DoxyParams}{Parameters}
{\em buf} & A pointer to an array of character data. \\
\hline
{\em len} & The length of the string. If $<$ 0 then all characters will be displayed until a null character is encountered. \\
\hline
{\em position} & T\+O\+DO \\
\hline
{\em render\+Mode} & Render mode to display \\
\hline
{\em Remaining\+Width} & The amount of extra space left on the line. \\
\hline
{\em bounds} & A pointer to a bounds object. If non null the bounds will be initialized or expanded by the bounds of the line. If null the text will be rendered. If the bounds are invalid (lower $>$ upper) they will be initialized. Otherwise they will be expanded. \\
\hline
\end{DoxyParams}
\index{F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}!Output\+Wrapped@{Output\+Wrapped}}
\index{Output\+Wrapped@{Output\+Wrapped}!F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}}
\subsubsection[{\texorpdfstring{Output\+Wrapped(const wchar\+\_\+t $\ast$buf, const int len, F\+T\+Point position, int render\+Mode, const float Remaining\+Width, F\+T\+B\+Box $\ast$bounds)}{OutputWrapped(const wchar_t *buf, const int len, FTPoint position, int renderMode, const float RemainingWidth, FTBBox *bounds)}}]{\setlength{\rightskip}{0pt plus 5cm}void F\+T\+Simple\+Layout\+Impl\+::\+Output\+Wrapped (
\begin{DoxyParamCaption}
\item[{const wchar\+\_\+t $\ast$}]{buf, }
\item[{const int}]{len, }
\item[{F\+T\+Point}]{position, }
\item[{int}]{render\+Mode, }
\item[{const float}]{Remaining\+Width, }
\item[{F\+T\+B\+Box $\ast$}]{bounds}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_f_t_simple_layout_impl_a8a0e01a58af988be392daad3187f1139}{}\label{class_f_t_simple_layout_impl_a8a0e01a58af988be392daad3187f1139}
A helper method used by Wrap\+Text to either output the text or compute it\textquotesingle{}s bounds.


\begin{DoxyParams}{Parameters}
{\em buf} & A pointer to an array of character data. \\
\hline
{\em len} & The length of the string. If $<$ 0 then all characters will be displayed until a null character is encountered. \\
\hline
{\em position} & T\+O\+DO \\
\hline
{\em render\+Mode} & Render mode to display \\
\hline
{\em Remaining\+Width} & The amount of extra space left on the line. \\
\hline
{\em bounds} & A pointer to a bounds object. If non null the bounds will be initialized or expanded by the bounds of the line. If null the text will be rendered. If the bounds are invalid (lower $>$ upper) they will be initialized. Otherwise they will be expanded. \\
\hline
\end{DoxyParams}
\index{F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}!Render\+Space@{Render\+Space}}
\index{Render\+Space@{Render\+Space}!F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}}
\subsubsection[{\texorpdfstring{Render\+Space(const char $\ast$string, const int len, F\+T\+Point position, int render\+Mode, const float extra\+Space)}{RenderSpace(const char *string, const int len, FTPoint position, int renderMode, const float extraSpace)}}]{\setlength{\rightskip}{0pt plus 5cm}void F\+T\+Simple\+Layout\+Impl\+::\+Render\+Space (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{string, }
\item[{const int}]{len, }
\item[{F\+T\+Point}]{position, }
\item[{int}]{render\+Mode, }
\item[{const float}]{extra\+Space}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{class_f_t_simple_layout_impl_abdbd064c650f1e17d2bd3139536aff47}{}\label{class_f_t_simple_layout_impl_abdbd064c650f1e17d2bd3139536aff47}
Render a string of characters and distribute extra space amongst the whitespace regions of the string.


\begin{DoxyParams}{Parameters}
{\em string} & A buffer of wchar\+\_\+t characters to output. \\
\hline
{\em len} & The length of the string. If $<$ 0 then all characters will be displayed until a null character is encountered. \\
\hline
{\em position} & T\+O\+DO \\
\hline
{\em render\+Mode} & Render mode to display \\
\hline
{\em extra\+Space} & The amount of extra space to distribute amongst the characters. \\
\hline
\end{DoxyParams}
\index{F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}!Render\+Space@{Render\+Space}}
\index{Render\+Space@{Render\+Space}!F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}}
\subsubsection[{\texorpdfstring{Render\+Space(const wchar\+\_\+t $\ast$string, const int len, F\+T\+Point position, int render\+Mode, const float extra\+Space)}{RenderSpace(const wchar_t *string, const int len, FTPoint position, int renderMode, const float extraSpace)}}]{\setlength{\rightskip}{0pt plus 5cm}void F\+T\+Simple\+Layout\+Impl\+::\+Render\+Space (
\begin{DoxyParamCaption}
\item[{const wchar\+\_\+t $\ast$}]{string, }
\item[{const int}]{len, }
\item[{F\+T\+Point}]{position, }
\item[{int}]{render\+Mode, }
\item[{const float}]{extra\+Space}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\hypertarget{class_f_t_simple_layout_impl_a6b5334d053e9c79dd459f8b88c0e60a4}{}\label{class_f_t_simple_layout_impl_a6b5334d053e9c79dd459f8b88c0e60a4}
Render a string of characters and distribute extra space amongst the whitespace regions of the string.


\begin{DoxyParams}{Parameters}
{\em string} & A buffer of wchar\+\_\+t characters to output. \\
\hline
{\em len} & The length of the string. If $<$ 0 then all characters will be displayed until a null character is encountered. \\
\hline
{\em position} & T\+O\+DO \\
\hline
{\em render\+Mode} & Render mode to display \\
\hline
{\em extra\+Space} & The amount of extra space to distribute amongst the characters. \\
\hline
\end{DoxyParams}
\index{F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}!Wrap\+Text@{Wrap\+Text}}
\index{Wrap\+Text@{Wrap\+Text}!F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}}
\subsubsection[{\texorpdfstring{Wrap\+Text(const char $\ast$buf, const int len, F\+T\+Point position, int render\+Mode, F\+T\+B\+Box $\ast$bounds)}{WrapText(const char *buf, const int len, FTPoint position, int renderMode, FTBBox *bounds)}}]{\setlength{\rightskip}{0pt plus 5cm}void F\+T\+Simple\+Layout\+Impl\+::\+Wrap\+Text (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{buf, }
\item[{const int}]{len, }
\item[{F\+T\+Point}]{position, }
\item[{int}]{render\+Mode, }
\item[{F\+T\+B\+Box $\ast$}]{bounds}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{class_f_t_simple_layout_impl_aefdfcffcfca03e0139db7e21c968f7c5}{}\label{class_f_t_simple_layout_impl_aefdfcffcfca03e0139db7e21c968f7c5}
Either render a string of characters and wrap lines longer than a threshold or compute the bounds of a string of characters when wrapped. The functionality of this method is exposed by the B\+Box\+Wrapped and Render\+Wrapped methods.


\begin{DoxyParams}{Parameters}
{\em buf} & A char string to output. \\
\hline
{\em len} & The length of the string. If $<$ 0 then all characters will be displayed until a null character is encountered. \\
\hline
{\em position} & T\+O\+DO \\
\hline
{\em render\+Mode} & Render mode to display \\
\hline
{\em bounds} & A pointer to a bounds object. If non null the bounds of the text when laid out will be stored in bounds. If null the text will be rendered. \\
\hline
\end{DoxyParams}
\index{F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}!Wrap\+Text@{Wrap\+Text}}
\index{Wrap\+Text@{Wrap\+Text}!F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}}
\subsubsection[{\texorpdfstring{Wrap\+Text(const wchar\+\_\+t $\ast$buf, const int len, F\+T\+Point position, int render\+Mode, F\+T\+B\+Box $\ast$bounds)}{WrapText(const wchar_t *buf, const int len, FTPoint position, int renderMode, FTBBox *bounds)}}]{\setlength{\rightskip}{0pt plus 5cm}void F\+T\+Simple\+Layout\+Impl\+::\+Wrap\+Text (
\begin{DoxyParamCaption}
\item[{const wchar\+\_\+t $\ast$}]{buf, }
\item[{const int}]{len, }
\item[{F\+T\+Point}]{position, }
\item[{int}]{render\+Mode, }
\item[{F\+T\+B\+Box $\ast$}]{bounds}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [virtual]}}\hypertarget{class_f_t_simple_layout_impl_a344c5b35b3b02da0deea00b337017389}{}\label{class_f_t_simple_layout_impl_a344c5b35b3b02da0deea00b337017389}
Either render a string of characters and wrap lines longer than a threshold or compute the bounds of a string of characters when wrapped. The functionality of this method is exposed by the B\+Box\+Wrapped and Render\+Wrapped methods.


\begin{DoxyParams}{Parameters}
{\em buf} & A wchar\+\_\+t style string to output. \\
\hline
{\em len} & The length of the string. If $<$ 0 then all characters will be displayed until a null character is encountered. \\
\hline
{\em position} & T\+O\+DO \\
\hline
{\em render\+Mode} & Render mode to display \\
\hline
{\em bounds} & A pointer to a bounds object. If non null the bounds of the text when laid out will be stored in bounds. If null the text will be rendered. \\
\hline
\end{DoxyParams}


\subsection{Member Data Documentation}
\index{F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}!alignment@{alignment}}
\index{alignment@{alignment}!F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}}
\subsubsection[{\texorpdfstring{alignment}{alignment}}]{\setlength{\rightskip}{0pt plus 5cm}F\+T\+G\+L\+::\+Text\+Alignment F\+T\+Simple\+Layout\+Impl\+::alignment\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_f_t_simple_layout_impl_a0f0edb7cdf27a22fe66f635c56aa0dbd}{}\label{class_f_t_simple_layout_impl_a0f0edb7cdf27a22fe66f635c56aa0dbd}
The text alignment mode used to distribute space within a line or rendered text. \index{F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}!current\+Font@{current\+Font}}
\index{current\+Font@{current\+Font}!F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}}
\subsubsection[{\texorpdfstring{current\+Font}{currentFont}}]{\setlength{\rightskip}{0pt plus 5cm}F\+T\+Font$\ast$ F\+T\+Simple\+Layout\+Impl\+::current\+Font\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_f_t_simple_layout_impl_af77c6b00911959673e6e45275bccd128}{}\label{class_f_t_simple_layout_impl_af77c6b00911959673e6e45275bccd128}
The font to use for rendering the text. The font is referenced by this but will not be disposed of when this is deleted. \index{F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}!line\+Length@{line\+Length}}
\index{line\+Length@{line\+Length}!F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}}
\subsubsection[{\texorpdfstring{line\+Length}{lineLength}}]{\setlength{\rightskip}{0pt plus 5cm}float F\+T\+Simple\+Layout\+Impl\+::line\+Length\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_f_t_simple_layout_impl_a46da513a479522dd9fe9ab752a761b3e}{}\label{class_f_t_simple_layout_impl_a46da513a479522dd9fe9ab752a761b3e}
The maximum line length for formatting text. \index{F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}!line\+Spacing@{line\+Spacing}}
\index{line\+Spacing@{line\+Spacing}!F\+T\+Simple\+Layout\+Impl@{F\+T\+Simple\+Layout\+Impl}}
\subsubsection[{\texorpdfstring{line\+Spacing}{lineSpacing}}]{\setlength{\rightskip}{0pt plus 5cm}float F\+T\+Simple\+Layout\+Impl\+::line\+Spacing\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_f_t_simple_layout_impl_a0afb3dda6e096069602a8df941293605}{}\label{class_f_t_simple_layout_impl_a0afb3dda6e096069602a8df941293605}
The height of each line of text expressed as a percentage of the font\textquotesingle{}s line height. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
Commun/\+Externe/\+F\+T\+G\+L/include/\+F\+T\+Layout/F\+T\+Simple\+Layout\+Impl.\+h\item 
Commun/\+Externe/\+F\+T\+G\+L/include/\+F\+T\+Layout/F\+T\+Simple\+Layout.\+cpp\end{DoxyCompactItemize}
