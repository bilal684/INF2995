\hypertarget{b2_collision_8h}{}\section{Cadriciel/\+Commun/\+Externe/\+Box2\+D/include/\+Box2\+D/\+Collision/b2\+Collision.h File Reference}
\label{b2_collision_8h}\index{Cadriciel/\+Commun/\+Externe/\+Box2\+D/include/\+Box2\+D/\+Collision/b2\+Collision.\+h@{Cadriciel/\+Commun/\+Externe/\+Box2\+D/include/\+Box2\+D/\+Collision/b2\+Collision.\+h}}
{\ttfamily \#include $<$Box2\+D/\+Common/b2\+Math.\+h$>$}\\*
{\ttfamily \#include $<$limits.\+h$>$}\\*
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structb2_contact_feature}{b2\+Contact\+Feature}
\item 
union \hyperlink{unionb2_contact_i_d}{b2\+Contact\+ID}
\begin{DoxyCompactList}\small\item\em Contact ids to facilitate warm starting. \end{DoxyCompactList}\item 
struct \hyperlink{structb2_manifold_point}{b2\+Manifold\+Point}
\item 
struct \hyperlink{structb2_manifold}{b2\+Manifold}
\item 
struct \hyperlink{structb2_world_manifold}{b2\+World\+Manifold}
\begin{DoxyCompactList}\small\item\em This is used to compute the current state of a contact manifold. \end{DoxyCompactList}\item 
struct \hyperlink{structb2_clip_vertex}{b2\+Clip\+Vertex}
\begin{DoxyCompactList}\small\item\em Used for computing contact manifolds. \end{DoxyCompactList}\item 
struct \hyperlink{structb2_ray_cast_input}{b2\+Ray\+Cast\+Input}
\begin{DoxyCompactList}\small\item\em Ray-\/cast input data. The ray extends from p1 to p1 + max\+Fraction $\ast$ (p2 -\/ p1). \end{DoxyCompactList}\item 
struct \hyperlink{structb2_ray_cast_output}{b2\+Ray\+Cast\+Output}
\item 
struct \hyperlink{structb2_a_a_b_b}{b2\+A\+A\+BB}
\begin{DoxyCompactList}\small\item\em An axis aligned bounding box. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663d}{b2\+Point\+State} \{ \hyperlink{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663da7ce77ce1a592f49d92939997976c217b}{b2\+\_\+null\+State}, 
\hyperlink{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663dac60dc479bee2089a695b37948179b3d4}{b2\+\_\+add\+State}, 
\hyperlink{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663dafb032f2175741fa95361e55d1c069e0a}{b2\+\_\+persist\+State}, 
\hyperlink{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663da42ca6d7de57b948c8c895cd6f51ee8be}{b2\+\_\+remove\+State}
 \}\begin{DoxyCompactList}\small\item\em This is used for determining the state of contact points. \end{DoxyCompactList}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{b2_collision_8h_a401e2747d276e9fbfd131989e02ff568}{b2\+Get\+Point\+States} (\hyperlink{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663d}{b2\+Point\+State} state1\mbox{[}\hyperlink{b2_settings_8h_aa5f44cc9edf711433dea2b2ec94f3c42}{b2\+\_\+max\+Manifold\+Points}\mbox{]}, \hyperlink{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663d}{b2\+Point\+State} state2\mbox{[}\hyperlink{b2_settings_8h_aa5f44cc9edf711433dea2b2ec94f3c42}{b2\+\_\+max\+Manifold\+Points}\mbox{]}, const \hyperlink{structb2_manifold}{b2\+Manifold} $\ast$manifold1, const \hyperlink{structb2_manifold}{b2\+Manifold} $\ast$manifold2)
\item 
void \hyperlink{b2_collision_8h_ab8a1bf2c6a9453307466f4870c1fa333}{b2\+Collide\+Circles} (\hyperlink{structb2_manifold}{b2\+Manifold} $\ast$manifold, const \hyperlink{classb2_circle_shape}{b2\+Circle\+Shape} $\ast$circleA, const \hyperlink{structb2_transform}{b2\+Transform} \&xfA, const \hyperlink{classb2_circle_shape}{b2\+Circle\+Shape} $\ast$circleB, const \hyperlink{structb2_transform}{b2\+Transform} \&xfB)\hypertarget{b2_collision_8h_ab8a1bf2c6a9453307466f4870c1fa333}{}\label{b2_collision_8h_ab8a1bf2c6a9453307466f4870c1fa333}

\begin{DoxyCompactList}\small\item\em Compute the collision manifold between two circles. \end{DoxyCompactList}\item 
void \hyperlink{b2_collision_8h_a30da13c857596fbefa40b47c3e1e78d0}{b2\+Collide\+Polygon\+And\+Circle} (\hyperlink{structb2_manifold}{b2\+Manifold} $\ast$manifold, const \hyperlink{classb2_polygon_shape}{b2\+Polygon\+Shape} $\ast$polygonA, const \hyperlink{structb2_transform}{b2\+Transform} \&xfA, const \hyperlink{classb2_circle_shape}{b2\+Circle\+Shape} $\ast$circleB, const \hyperlink{structb2_transform}{b2\+Transform} \&xfB)\hypertarget{b2_collision_8h_a30da13c857596fbefa40b47c3e1e78d0}{}\label{b2_collision_8h_a30da13c857596fbefa40b47c3e1e78d0}

\begin{DoxyCompactList}\small\item\em Compute the collision manifold between a polygon and a circle. \end{DoxyCompactList}\item 
void \hyperlink{b2_collision_8h_a2f7b9859479384c0e2cceb9e7744afcb}{b2\+Collide\+Polygons} (\hyperlink{structb2_manifold}{b2\+Manifold} $\ast$manifold, const \hyperlink{classb2_polygon_shape}{b2\+Polygon\+Shape} $\ast$polygonA, const \hyperlink{structb2_transform}{b2\+Transform} \&xfA, const \hyperlink{classb2_polygon_shape}{b2\+Polygon\+Shape} $\ast$polygonB, const \hyperlink{structb2_transform}{b2\+Transform} \&xfB)\hypertarget{b2_collision_8h_a2f7b9859479384c0e2cceb9e7744afcb}{}\label{b2_collision_8h_a2f7b9859479384c0e2cceb9e7744afcb}

\begin{DoxyCompactList}\small\item\em Compute the collision manifold between two polygons. \end{DoxyCompactList}\item 
void \hyperlink{b2_collision_8h_aee6f752fdf8c89152e824da12e944733}{b2\+Collide\+Edge\+And\+Circle} (\hyperlink{structb2_manifold}{b2\+Manifold} $\ast$manifold, const \hyperlink{classb2_edge_shape}{b2\+Edge\+Shape} $\ast$polygonA, const \hyperlink{structb2_transform}{b2\+Transform} \&xfA, const \hyperlink{classb2_circle_shape}{b2\+Circle\+Shape} $\ast$circleB, const \hyperlink{structb2_transform}{b2\+Transform} \&xfB)\hypertarget{b2_collision_8h_aee6f752fdf8c89152e824da12e944733}{}\label{b2_collision_8h_aee6f752fdf8c89152e824da12e944733}

\begin{DoxyCompactList}\small\item\em Compute the collision manifold between an edge and a circle. \end{DoxyCompactList}\item 
void \hyperlink{b2_collision_8h_a5d0c5fab412d5ca886b1965666b16d99}{b2\+Collide\+Edge\+And\+Polygon} (\hyperlink{structb2_manifold}{b2\+Manifold} $\ast$manifold, const \hyperlink{classb2_edge_shape}{b2\+Edge\+Shape} $\ast$edgeA, const \hyperlink{structb2_transform}{b2\+Transform} \&xfA, const \hyperlink{classb2_polygon_shape}{b2\+Polygon\+Shape} $\ast$circleB, const \hyperlink{structb2_transform}{b2\+Transform} \&xfB)\hypertarget{b2_collision_8h_a5d0c5fab412d5ca886b1965666b16d99}{}\label{b2_collision_8h_a5d0c5fab412d5ca886b1965666b16d99}

\begin{DoxyCompactList}\small\item\em Compute the collision manifold between an edge and a circle. \end{DoxyCompactList}\item 
int32 \hyperlink{b2_collision_8h_a8b36e651798f55f2533f9837462ded41}{b2\+Clip\+Segment\+To\+Line} (\hyperlink{structb2_clip_vertex}{b2\+Clip\+Vertex} v\+Out\mbox{[}2\mbox{]}, const \hyperlink{structb2_clip_vertex}{b2\+Clip\+Vertex} v\+In\mbox{[}2\mbox{]}, const \hyperlink{structb2_vec2}{b2\+Vec2} \&normal, float32 offset, int32 vertex\+IndexA)\hypertarget{b2_collision_8h_a8b36e651798f55f2533f9837462ded41}{}\label{b2_collision_8h_a8b36e651798f55f2533f9837462ded41}

\begin{DoxyCompactList}\small\item\em Clipping for contact manifolds. \end{DoxyCompactList}\item 
bool \hyperlink{b2_collision_8h_ae7601420d0b42c1ee494e879dd2009a5}{b2\+Test\+Overlap} (const \hyperlink{classb2_shape}{b2\+Shape} $\ast$shapeA, int32 indexA, const \hyperlink{classb2_shape}{b2\+Shape} $\ast$shapeB, int32 indexB, const \hyperlink{structb2_transform}{b2\+Transform} \&xfA, const \hyperlink{structb2_transform}{b2\+Transform} \&xfB)\hypertarget{b2_collision_8h_ae7601420d0b42c1ee494e879dd2009a5}{}\label{b2_collision_8h_ae7601420d0b42c1ee494e879dd2009a5}

\begin{DoxyCompactList}\small\item\em Determine if two generic shapes overlap. \end{DoxyCompactList}\item 
bool {\bfseries b2\+Test\+Overlap} (const \hyperlink{structb2_a_a_b_b}{b2\+A\+A\+BB} \&a, const \hyperlink{structb2_a_a_b_b}{b2\+A\+A\+BB} \&b)\hypertarget{b2_collision_8h_a3dea7a8a1115626c450a697f6c6bf97e}{}\label{b2_collision_8h_a3dea7a8a1115626c450a697f6c6bf97e}

\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const uint8 {\bfseries b2\+\_\+null\+Feature} = U\+C\+H\+A\+R\+\_\+\+M\+AX\hypertarget{b2_collision_8h_a910fdc8a802b3cac220f2ee873109818}{}\label{b2_collision_8h_a910fdc8a802b3cac220f2ee873109818}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Structures and functions used for computing contact points, distance queries, and T\+OI queries. 

\subsection{Enumeration Type Documentation}
\index{b2\+Collision.\+h@{b2\+Collision.\+h}!b2\+Point\+State@{b2\+Point\+State}}
\index{b2\+Point\+State@{b2\+Point\+State}!b2\+Collision.\+h@{b2\+Collision.\+h}}
\subsubsection[{\texorpdfstring{b2\+Point\+State}{b2PointState}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf b2\+Point\+State}}\hypertarget{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663d}{}\label{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663d}


This is used for determining the state of contact points. 

\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{b2\+\_\+null\+State@{b2\+\_\+null\+State}!b2\+Collision.\+h@{b2\+Collision.\+h}}\index{b2\+Collision.\+h@{b2\+Collision.\+h}!b2\+\_\+null\+State@{b2\+\_\+null\+State}}\item[{\em 
b2\+\_\+null\+State\hypertarget{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663da7ce77ce1a592f49d92939997976c217b}{}\label{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663da7ce77ce1a592f49d92939997976c217b}
}]point does not exist \index{b2\+\_\+add\+State@{b2\+\_\+add\+State}!b2\+Collision.\+h@{b2\+Collision.\+h}}\index{b2\+Collision.\+h@{b2\+Collision.\+h}!b2\+\_\+add\+State@{b2\+\_\+add\+State}}\item[{\em 
b2\+\_\+add\+State\hypertarget{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663dac60dc479bee2089a695b37948179b3d4}{}\label{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663dac60dc479bee2089a695b37948179b3d4}
}]point was added in the update \index{b2\+\_\+persist\+State@{b2\+\_\+persist\+State}!b2\+Collision.\+h@{b2\+Collision.\+h}}\index{b2\+Collision.\+h@{b2\+Collision.\+h}!b2\+\_\+persist\+State@{b2\+\_\+persist\+State}}\item[{\em 
b2\+\_\+persist\+State\hypertarget{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663dafb032f2175741fa95361e55d1c069e0a}{}\label{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663dafb032f2175741fa95361e55d1c069e0a}
}]point persisted across the update \index{b2\+\_\+remove\+State@{b2\+\_\+remove\+State}!b2\+Collision.\+h@{b2\+Collision.\+h}}\index{b2\+Collision.\+h@{b2\+Collision.\+h}!b2\+\_\+remove\+State@{b2\+\_\+remove\+State}}\item[{\em 
b2\+\_\+remove\+State\hypertarget{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663da42ca6d7de57b948c8c895cd6f51ee8be}{}\label{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663da42ca6d7de57b948c8c895cd6f51ee8be}
}]point was removed in the update \end{description}
\end{Desc}


\subsection{Function Documentation}
\index{b2\+Collision.\+h@{b2\+Collision.\+h}!b2\+Get\+Point\+States@{b2\+Get\+Point\+States}}
\index{b2\+Get\+Point\+States@{b2\+Get\+Point\+States}!b2\+Collision.\+h@{b2\+Collision.\+h}}
\subsubsection[{\texorpdfstring{b2\+Get\+Point\+States(b2\+Point\+State state1[b2\+\_\+max\+Manifold\+Points], b2\+Point\+State state2[b2\+\_\+max\+Manifold\+Points], const b2\+Manifold $\ast$manifold1, const b2\+Manifold $\ast$manifold2)}{b2GetPointStates(b2PointState state1[b2_maxManifoldPoints], b2PointState state2[b2_maxManifoldPoints], const b2Manifold *manifold1, const b2Manifold *manifold2)}}]{\setlength{\rightskip}{0pt plus 5cm}void b2\+Get\+Point\+States (
\begin{DoxyParamCaption}
\item[{{\bf b2\+Point\+State}}]{state1\mbox{[}b2\+\_\+max\+Manifold\+Points\mbox{]}, }
\item[{{\bf b2\+Point\+State}}]{state2\mbox{[}b2\+\_\+max\+Manifold\+Points\mbox{]}, }
\item[{const {\bf b2\+Manifold} $\ast$}]{manifold1, }
\item[{const {\bf b2\+Manifold} $\ast$}]{manifold2}
\end{DoxyParamCaption}
)}\hypertarget{b2_collision_8h_a401e2747d276e9fbfd131989e02ff568}{}\label{b2_collision_8h_a401e2747d276e9fbfd131989e02ff568}
Compute the point states given two manifolds. The states pertain to the transition from manifold1 to manifold2. So state1 is either persist or remove while state2 is either add or persist. 