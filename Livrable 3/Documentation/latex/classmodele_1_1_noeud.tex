\hypertarget{classmodele_1_1_noeud}{}\section{modele\+:\+:Noeud Class Reference}
\label{classmodele_1_1_noeud}\index{modele\+::\+Noeud@{modele\+::\+Noeud}}


Classe qui encapsule un arbre composé de meshes et de matrices de transformations.  




{\ttfamily \#include $<$Noeud.\+h$>$}

\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T $>$ }\\using {\bfseries Conteneur} = std\+::vector$<$ T $>$\hypertarget{classmodele_1_1_noeud_aebc16c98cd928d1cc3167c8bbffc1d40}{}\label{classmodele_1_1_noeud_aebc16c98cd928d1cc3167c8bbffc1d40}

\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmodele_1_1_noeud_af36dc9d97d88a25fb09379831a5ac117}{Noeud} (ai\+Scene const $\ast$scene, ai\+Node const $\ast$noeud)
\begin{DoxyCompactList}\small\item\em Constructeur à partir d\textquotesingle{}une scène et d\textquotesingle{}un noeud assimp. \end{DoxyCompactList}\item 
\hyperlink{classmodele_1_1_noeud_a41af554e17164a82f8fde7b5a06c245d}{Noeud} (\hyperlink{classmodele_1_1_noeud}{Noeud} \&\&noeud)
\begin{DoxyCompactList}\small\item\em Constructeur par transfert (\char`\"{}\+Move\char`\"{}) \end{DoxyCompactList}\item 
\hyperlink{classmodele_1_1_noeud}{Noeud} \& \hyperlink{classmodele_1_1_noeud_ae802c4f1ecdeae27a440f2705700834e}{operator=} (\hyperlink{classmodele_1_1_noeud}{Noeud} \&\&noeud)
\begin{DoxyCompactList}\small\item\em Assignation par transfert (\char`\"{}move\char`\"{}) \end{DoxyCompactList}\item 
\hyperlink{classmodele_1_1_noeud_a0b746cc9e13a4837b2f856691837397f}{Noeud} (\hyperlink{classmodele_1_1_noeud}{Noeud} const \&)=delete\hypertarget{classmodele_1_1_noeud_a0b746cc9e13a4837b2f856691837397f}{}\label{classmodele_1_1_noeud_a0b746cc9e13a4837b2f856691837397f}

\begin{DoxyCompactList}\small\item\em Constructeur par copie non-\/nécessaire dans le contexte. \end{DoxyCompactList}\item 
\hyperlink{classmodele_1_1_noeud}{Noeud} \& \hyperlink{classmodele_1_1_noeud_a7a44b7e1452a09b88f63ef76b22ddec4}{operator=} (\hyperlink{classmodele_1_1_noeud}{Noeud} const \&)=delete\hypertarget{classmodele_1_1_noeud_a7a44b7e1452a09b88f63ef76b22ddec4}{}\label{classmodele_1_1_noeud_a7a44b7e1452a09b88f63ef76b22ddec4}

\begin{DoxyCompactList}\small\item\em Assignation par copie non-\/nécessaire dans le contexte. \end{DoxyCompactList}\item 
Conteneur$<$ \hyperlink{classmodele_1_1_mesh}{Mesh} $>$ const \& \hyperlink{classmodele_1_1_noeud_a101a25623ebba2600f8543a6c19679e0}{obtenir\+Meshes} () const 
\begin{DoxyCompactList}\small\item\em Méthodes pour obtenir les meshes associés au noeud. \end{DoxyCompactList}\item 
Conteneur$<$ \hyperlink{classmodele_1_1_noeud}{Noeud} $>$ const \& \hyperlink{classmodele_1_1_noeud_a6963aeb02dc79278f93e83f0289c8d0f}{obtenir\+Enfants} () const 
\begin{DoxyCompactList}\small\item\em Méthodes pour obtenir les noeuds enfants. \end{DoxyCompactList}\item 
\hyperlink{group__core__types_ga63e3ee9447ed593484140a9368e738ec}{glm\+::mat4x4} const \& \hyperlink{classmodele_1_1_noeud_a87e5e968095dc830b8f1a008453f816f}{obtenir\+Transformation} () const 
\begin{DoxyCompactList}\small\item\em Méthodes pour obtenir la transformation associée au noeud. \end{DoxyCompactList}\item 
std\+::string const \& \hyperlink{classmodele_1_1_noeud_a92bd556c458afa1a690b7b253a6557fd}{obtenir\+Nom} () const 
\begin{DoxyCompactList}\small\item\em Méthodes pour obtenir le nom du noeud (souvent une chaine vide) \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Classe qui encapsule un arbre composé de meshes et de matrices de transformations. 

\begin{DoxyAuthor}{Author}
Martin Paradis 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
2014-\/08-\/16 
\end{DoxyDate}


\subsection{Constructor \& Destructor Documentation}
\index{modele\+::\+Noeud@{modele\+::\+Noeud}!Noeud@{Noeud}}
\index{Noeud@{Noeud}!modele\+::\+Noeud@{modele\+::\+Noeud}}
\subsubsection[{\texorpdfstring{Noeud(ai\+Scene const $\ast$scene, ai\+Node const $\ast$noeud)}{Noeud(aiScene const *scene, aiNode const *noeud)}}]{\setlength{\rightskip}{0pt plus 5cm}modele\+::\+Noeud\+::\+Noeud (
\begin{DoxyParamCaption}
\item[{ai\+Scene const $\ast$}]{scene, }
\item[{ai\+Node const $\ast$}]{noeud}
\end{DoxyParamCaption}
)}\hypertarget{classmodele_1_1_noeud_af36dc9d97d88a25fb09379831a5ac117}{}\label{classmodele_1_1_noeud_af36dc9d97d88a25fb09379831a5ac117}


Constructeur à partir d\textquotesingle{}une scène et d\textquotesingle{}un noeud assimp. 

Construit un noeud à partir d\textquotesingle{}une scène et d\textquotesingle{}un noeud assimp.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em scene} & \+: Scene assimp contenant le modèle chargé \\
\hline
\mbox{\tt in}  & {\em noeud} & \+: Le noeud de la scène à charger\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Aucune. 
\end{DoxyReturn}
Conserver le nom du noeud

Convertir la matrice assimp en matrice glm

Pour éviter les multiples allocations de mémoire

Ajouter et constuire toutes les meshes du noeud courant

Pour éviter les multiples allocations de mémoire

Ajouter et construire tous les noeuds enfants \index{modele\+::\+Noeud@{modele\+::\+Noeud}!Noeud@{Noeud}}
\index{Noeud@{Noeud}!modele\+::\+Noeud@{modele\+::\+Noeud}}
\subsubsection[{\texorpdfstring{Noeud(\+Noeud \&\&noeud)}{Noeud(Noeud &&noeud)}}]{\setlength{\rightskip}{0pt plus 5cm}modele\+::\+Noeud\+::\+Noeud (
\begin{DoxyParamCaption}
\item[{{\bf Noeud} \&\&}]{noeud}
\end{DoxyParamCaption}
)}\hypertarget{classmodele_1_1_noeud_a41af554e17164a82f8fde7b5a06c245d}{}\label{classmodele_1_1_noeud_a41af554e17164a82f8fde7b5a06c245d}


Constructeur par transfert (\char`\"{}\+Move\char`\"{}) 

Constructeur \char`\"{}move\char`\"{}. Utilise l\textquotesingle{}assignation \char`\"{}move\char`\"{}.

\begin{DoxyReturn}{Returns}
Aucune. 
\end{DoxyReturn}


\subsection{Member Function Documentation}
\index{modele\+::\+Noeud@{modele\+::\+Noeud}!obtenir\+Enfants@{obtenir\+Enfants}}
\index{obtenir\+Enfants@{obtenir\+Enfants}!modele\+::\+Noeud@{modele\+::\+Noeud}}
\subsubsection[{\texorpdfstring{obtenir\+Enfants() const }{obtenirEnfants() const }}]{\setlength{\rightskip}{0pt plus 5cm}Noeud\+::\+Conteneur$<$ {\bf Noeud} $>$ const \& modele\+::\+Noeud\+::obtenir\+Enfants (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classmodele_1_1_noeud_a6963aeb02dc79278f93e83f0289c8d0f}{}\label{classmodele_1_1_noeud_a6963aeb02dc79278f93e83f0289c8d0f}


Méthodes pour obtenir les noeuds enfants. 

Cette fonction retourne les noeuds enfants du noeud courant;

\begin{DoxyReturn}{Returns}
Le conteneur des enfants (const). 
\end{DoxyReturn}
\index{modele\+::\+Noeud@{modele\+::\+Noeud}!obtenir\+Meshes@{obtenir\+Meshes}}
\index{obtenir\+Meshes@{obtenir\+Meshes}!modele\+::\+Noeud@{modele\+::\+Noeud}}
\subsubsection[{\texorpdfstring{obtenir\+Meshes() const }{obtenirMeshes() const }}]{\setlength{\rightskip}{0pt plus 5cm}Noeud\+::\+Conteneur$<$ {\bf Mesh} $>$ const \& modele\+::\+Noeud\+::obtenir\+Meshes (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classmodele_1_1_noeud_a101a25623ebba2600f8543a6c19679e0}{}\label{classmodele_1_1_noeud_a101a25623ebba2600f8543a6c19679e0}


Méthodes pour obtenir les meshes associés au noeud. 

Cette fonction retourne les meshes associés au noeud courant (ne contient donc pas les meshes des noeuds enfants.

\begin{DoxyReturn}{Returns}
Le conteneur des meshes (const). 
\end{DoxyReturn}
\index{modele\+::\+Noeud@{modele\+::\+Noeud}!obtenir\+Nom@{obtenir\+Nom}}
\index{obtenir\+Nom@{obtenir\+Nom}!modele\+::\+Noeud@{modele\+::\+Noeud}}
\subsubsection[{\texorpdfstring{obtenir\+Nom() const }{obtenirNom() const }}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string const \& modele\+::\+Noeud\+::obtenir\+Nom (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classmodele_1_1_noeud_a92bd556c458afa1a690b7b253a6557fd}{}\label{classmodele_1_1_noeud_a92bd556c458afa1a690b7b253a6557fd}


Méthodes pour obtenir le nom du noeud (souvent une chaine vide) 

Cette fonction retourne le nom du noeud courant. Le nom des noeuds est très souvent vide (cela dépend du type de fichier utilisé).

\begin{DoxyReturn}{Returns}
Le nom du noeud (const). 
\end{DoxyReturn}
\index{modele\+::\+Noeud@{modele\+::\+Noeud}!obtenir\+Transformation@{obtenir\+Transformation}}
\index{obtenir\+Transformation@{obtenir\+Transformation}!modele\+::\+Noeud@{modele\+::\+Noeud}}
\subsubsection[{\texorpdfstring{obtenir\+Transformation() const }{obtenirTransformation() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf glm\+::mat4x4} const \& modele\+::\+Noeud\+::obtenir\+Transformation (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classmodele_1_1_noeud_a87e5e968095dc830b8f1a008453f816f}{}\label{classmodele_1_1_noeud_a87e5e968095dc830b8f1a008453f816f}


Méthodes pour obtenir la transformation associée au noeud. 

Cette fonction retourne la transformation du noeud courant;

\begin{DoxyReturn}{Returns}
La matrice de transformation (const). 
\end{DoxyReturn}
\index{modele\+::\+Noeud@{modele\+::\+Noeud}!operator=@{operator=}}
\index{operator=@{operator=}!modele\+::\+Noeud@{modele\+::\+Noeud}}
\subsubsection[{\texorpdfstring{operator=(\+Noeud \&\&noeud)}{operator=(Noeud &&noeud)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Noeud} \& modele\+::\+Noeud\+::operator= (
\begin{DoxyParamCaption}
\item[{{\bf Noeud} \&\&}]{noeud}
\end{DoxyParamCaption}
)}\hypertarget{classmodele_1_1_noeud_ae802c4f1ecdeae27a440f2705700834e}{}\label{classmodele_1_1_noeud_ae802c4f1ecdeae27a440f2705700834e}


Assignation par transfert (\char`\"{}move\char`\"{}) 

Assignation par transfert (\char`\"{}move\char`\"{}), ne fait que transférer les données.

\begin{DoxyReturn}{Returns}
le noeud courant. 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
Cadriciel/\+Commun/\+Utilitaire/\+Modele/\hyperlink{_noeud_8h}{Noeud.\+h}\item 
Cadriciel/\+Commun/\+Utilitaire/\+Modele/\hyperlink{_noeud_8cpp}{Noeud.\+cpp}\end{DoxyCompactItemize}
