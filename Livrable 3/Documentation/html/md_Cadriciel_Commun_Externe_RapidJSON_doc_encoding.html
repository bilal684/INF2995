<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>INF2990 - Livrable 3: Encoding</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">INF2990 - Livrable 3
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Encoding </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Unicode">Unicode</a><ul><li class="level2"><a href="#UTF">Unicode Transformation Format</a></li>
<li class="level2"><a href="#CharacterType">Character Type</a></li>
<li class="level2"><a href="#AutoUTF">AutoUTF</a></li>
<li class="level2"><a href="#ASCII">ASCII</a></li>
</ul>
</li>
<li class="level1"><a href="#ValidationTranscoding">Validation &amp; Transcoding</a><ul><li class="level2"><a href="#Transcoder">Transcoder</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>According to <a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf">ECMA-404</a>,</p>
<blockquote class="doxtable">
<p>(in Introduction) JSON text is a sequence of Unicode code points. </p>
</blockquote>
<p>The earlier <a href="http://www.ietf.org/rfc/rfc4627.txt">RFC4627</a> stated that,</p>
<blockquote class="doxtable">
<p>(in §3) JSON text SHALL be encoded in Unicode. The default encoding is UTF-8. </p>
</blockquote>
<blockquote class="doxtable">
<p>(in §6) JSON may be represented using UTF-8, UTF-16, or UTF-32. When JSON is written in UTF-8, JSON is 8bit compatible. When JSON is written in UTF-16 or UTF-32, the binary content-transfer-encoding must be used. </p>
</blockquote>
<p>RapidJSON supports various encodings. It can also validate the encodings of JSON, and transconding JSON among encodings. All these features are implemented internally, without the need for external libraries (e.g. <a href="http://site.icu-project.org/">ICU</a>).</p>
<h1><a class="anchor" id="Unicode"></a>
Unicode</h1>
<p>From <a href="http://www.unicode.org/standard/WhatIsUnicode.html">Unicode's official website</a>: </p><blockquote class="doxtable">
<p>Unicode provides a unique number for every character, no matter what the platform, no matter what the program, no matter what the language. </p>
</blockquote>
<p>Those unique numbers are called code points, which is in the range <code>0x0</code> to <code>0x10FFFF</code>.</p>
<h2><a class="anchor" id="UTF"></a>
Unicode Transformation Format</h2>
<p>There are various encodings for storing Unicode code points. These are called Unicode Transformation Format (UTF). RapidJSON supports the most commonly used UTFs, including</p>
<ul>
<li>UTF-8: 8-bit variable-width encoding. It maps a code point to 1–4 bytes.</li>
<li>UTF-16: 16-bit variable-width encoding. It maps a code point to 1–2 16-bit code units (i.e., 2–4 bytes).</li>
<li>UTF-32: 32-bit fixed-width encoding. It directly maps a code point to a single 32-bit code unit (i.e. 4 bytes).</li>
</ul>
<p>For UTF-16 and UTF-32, the byte order (endianness) does matter. Within computer memory, they are often stored in the computer's endianness. However, when it is stored in file or transferred over network, we need to state the byte order of the byte sequence, either little-endian (LE) or big-endian (BE).</p>
<p>RapidJSON provide these encodings via the structs in <code><a class="el" href="encodings_8h_source.html">rapidjson/encodings.h</a></code>:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacerapidjson.html">rapidjson</a> {</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharType = <span class="keywordtype">char</span>&gt;</div><div class="line"><span class="keyword">struct </span><a class="code" href="struct_u_t_f8.html">UTF8</a>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharType = <span class="keywordtype">wchar_t</span>&gt;</div><div class="line"><span class="keyword">struct </span><a class="code" href="struct_u_t_f16.html">UTF16</a>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharType = <span class="keywordtype">wchar_t</span>&gt;</div><div class="line"><span class="keyword">struct </span><a class="code" href="struct_u_t_f16_l_e.html">UTF16LE</a>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharType = <span class="keywordtype">wchar_t</span>&gt;</div><div class="line"><span class="keyword">struct </span><a class="code" href="struct_u_t_f16_b_e.html">UTF16BE</a>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharType = <span class="keywordtype">unsigned</span>&gt;</div><div class="line"><span class="keyword">struct </span><a class="code" href="struct_u_t_f32.html">UTF32</a>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharType = <span class="keywordtype">unsigned</span>&gt;</div><div class="line"><span class="keyword">struct </span><a class="code" href="struct_u_t_f32_l_e.html">UTF32LE</a>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharType = <span class="keywordtype">unsigned</span>&gt;</div><div class="line"><span class="keyword">struct </span><a class="code" href="struct_u_t_f32_b_e.html">UTF32BE</a>;</div><div class="line"></div><div class="line">} <span class="comment">// namespace rapidjson</span></div></div><!-- fragment --><p>For processing text in memory, we normally use <code><a class="el" href="struct_u_t_f8.html" title="UTF-8 encoding. ">UTF8</a></code>, <code><a class="el" href="struct_u_t_f16.html" title="UTF-16 encoding. ">UTF16</a></code> or <code><a class="el" href="struct_u_t_f32.html" title="UTF-32 encoding. ">UTF32</a></code>. For processing text via I/O, we may use <code><a class="el" href="struct_u_t_f8.html" title="UTF-8 encoding. ">UTF8</a></code>, <code><a class="el" href="struct_u_t_f16_l_e.html" title="UTF-16 little endian encoding. ">UTF16LE</a></code>, <code><a class="el" href="struct_u_t_f16_b_e.html" title="UTF-16 big endian encoding. ">UTF16BE</a></code>, <code><a class="el" href="struct_u_t_f32_l_e.html" title="UTF-32 little endian enocoding. ">UTF32LE</a></code> or <code><a class="el" href="struct_u_t_f32_b_e.html" title="UTF-32 big endian encoding. ">UTF32BE</a></code>.</p>
<p>When using the DOM-style API, the <code>Encoding</code> template parameter in <code><a class="el" href="class_generic_value.html" title="Represents a JSON value. Use Value for UTF8 encoding and default allocator. ">GenericValue</a>&lt;Encoding&gt;</code> and <code><a class="el" href="class_generic_document.html" title="A document for parsing JSON text as DOM. ">GenericDocument</a>&lt;Encoding&gt;</code> indicates the encoding to be used to represent JSON string in memory. So normally we will use <code><a class="el" href="struct_u_t_f8.html" title="UTF-8 encoding. ">UTF8</a></code>, <code><a class="el" href="struct_u_t_f16.html" title="UTF-16 encoding. ">UTF16</a></code> or <code><a class="el" href="struct_u_t_f32.html" title="UTF-32 encoding. ">UTF32</a></code> for this template parameter. The choice depends on operating systems and other libraries that the application is using. For example, Windows API represents Unicode characters in UTF-16, while most Linux distributions and applications prefer UTF-8.</p>
<p>Example of UTF-16 DOM declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="class_generic_document.html">GenericDocument&lt;UTF16&lt;&gt;</a> &gt; WDocument;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="class_generic_value.html">GenericValue&lt;UTF16&lt;&gt;</a> &gt; WValue;</div></div><!-- fragment --><p>For a detail example, please check the example in DOM's Encoding section.</p>
<h2><a class="anchor" id="CharacterType"></a>
Character Type</h2>
<p>As shown in the declaration, each encoding has a <code>CharType</code> template parameter. Actually, it may be a little bit confusing, but each <code>CharType</code> stores a code unit, not a character (code point). As mentioned in previous section, a code point may be encoded to 1–4 code units for UTF-8.</p>
<p>For <code><a class="el" href="struct_u_t_f16.html" title="UTF-16 encoding. ">UTF16</a>(LE|BE)</code>, <code><a class="el" href="struct_u_t_f32.html" title="UTF-32 encoding. ">UTF32</a>(LE|BE)</code>, the <code>CharType</code> must be integer type of at least 2 and 4 bytes respectively.</p>
<p>Note that C++11 introduces <code>char16_t</code> and <code>char32_t</code>, which can be used for <code><a class="el" href="struct_u_t_f16.html" title="UTF-16 encoding. ">UTF16</a></code> and <code><a class="el" href="struct_u_t_f32.html" title="UTF-32 encoding. ">UTF32</a></code> respectively.</p>
<h2><a class="anchor" id="AutoUTF"></a>
AutoUTF</h2>
<p>Previous encodings are statically bound in compile-time. In other words, user must know exactly which encodings will be used in the memory or streams. However, sometimes we may need to read/write files of different encodings. The encoding needed to be decided in runtime.</p>
<p><code><a class="el" href="struct_auto_u_t_f.html" title="Dynamically select encoding according to stream&#39;s runtime-specified UTF encoding type. ">AutoUTF</a></code> is an encoding designed for this purpose. It chooses which encoding to be used according to the input or output stream. Currently, it should be used with <code><a class="el" href="class_encoded_input_stream.html" title="Input byte stream wrapper with a statically bound encoding. ">EncodedInputStream</a></code> and <code><a class="el" href="class_encoded_output_stream.html" title="Output byte stream wrapper with statically bound encoding. ">EncodedOutputStream</a></code>.</p>
<h2><a class="anchor" id="ASCII"></a>
ASCII</h2>
<p>Although the JSON standards did not mention about <a href="http://en.wikipedia.org/wiki/ASCII">ASCII</a>, sometimes we would like to write 7-bit <a class="el" href="struct_a_s_c_i_i.html" title="ASCII encoding. ">ASCII</a> JSON for applications that cannot handle UTF-8. Since any JSON can represent unicode characters in escaped sequence <code>\uXXXX</code>, JSON can always be encoded in <a class="el" href="struct_a_s_c_i_i.html" title="ASCII encoding. ">ASCII</a>.</p>
<p>Here is an example for writing a UTF-8 DOM into <a class="el" href="struct_a_s_c_i_i.html" title="ASCII encoding. ">ASCII</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerapidjson.html">rapidjson</a>;</div><div class="line"><a class="code" href="class_generic_document.html">Document</a> d; <span class="comment">// UTF8&lt;&gt;</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><a class="code" href="class_generic_string_buffer.html">StringBuffer</a> buffer;</div><div class="line"><a class="code" href="class_writer.html">Writer&lt;StringBuffer, Document::EncodingType, ASCII&lt;&gt;</a> &gt; writer(buffer);</div><div class="line">d.Accept(writer);</div><div class="line">std::cout &lt;&lt; buffer.GetString();</div></div><!-- fragment --><p><a class="el" href="struct_a_s_c_i_i.html" title="ASCII encoding. ">ASCII</a> can be used in input stream. If the input stream contains bytes with values above 127, it will cause <code>kParseErrorStringInvalidEncoding</code> error.</p>
<p><a class="el" href="struct_a_s_c_i_i.html" title="ASCII encoding. ">ASCII</a> <em>cannot</em> be used in memory (encoding of <code>Document</code> or target encoding of <code>Reader</code>), as it cannot represent Unicode code points.</p>
<h1><a class="anchor" id="ValidationTranscoding"></a>
Validation &amp; Transcoding</h1>
<p>When RapidJSON parses a JSON, it can validate the input JSON, whether it is a valid sequence of a specified encoding. This option can be turned on by adding <code>kParseValidateEncodingFlag</code> in <code>parseFlags</code> template parameter.</p>
<p>If the input encoding and output encoding is different, <code>Reader</code> and <code><a class="el" href="class_writer.html" title="JSON writer. ">Writer</a></code> will automatically transcode (convert) the text. In this case, <code>kParseValidateEncodingFlag</code> is not necessary, as it must decode the input sequence. And if the sequence was unable to be decoded, it must be invalid.</p>
<h2><a class="anchor" id="Transcoder"></a>
Transcoder</h2>
<p>Although the encoding functions in RapidJSON are designed for JSON parsing/generation, user may abuse them for transcoding of non-JSON strings.</p>
<p>Here is an example for transcoding a string from UTF-8 to UTF-16:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rapidjson/encodings.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacerapidjson.html">rapidjson</a>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;...&quot;</span>; <span class="comment">// UTF-8 string</span></div><div class="line"><a class="code" href="struct_generic_string_stream.html">StringStream</a> source(s);</div><div class="line"><a class="code" href="class_generic_string_buffer.html">GenericStringBuffer&lt;UTF16&lt;&gt;</a> &gt; target;</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> hasError = <span class="keyword">false</span>;</div><div class="line"><span class="keywordflow">while</span> (source.Peak() != <span class="charliteral">&#39;\0&#39;</span>)</div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="struct_transcoder.html#a0ea2edfe35784ebf1063921d2bd5fb66">Transcoder::Transcode</a>&lt;<a class="code" href="struct_u_t_f8.html">UTF8&lt;&gt;</a>, <a class="code" href="struct_u_t_f16.html">UTF16&lt;&gt;</a> &gt;(source, target)) {</div><div class="line">        hasError = <span class="keyword">true</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (!hasError) {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* t = target.GetString();</div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --><p>You may also use <code><a class="el" href="struct_auto_u_t_f.html" title="Dynamically select encoding according to stream&#39;s runtime-specified UTF encoding type. ">AutoUTF</a></code> and the associated streams for setting source/target encoding in runtime. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
